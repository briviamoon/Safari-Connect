// File: app/auth/security.py
from datetime import datetime, timedelta
from jose import jwt
from app.config.settings import settings
import secrets

# shields
SECRET_KEY = secrets.token_hex(64)
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 1440

def create_access_token(data: dict):
    """Generates access token with set expiry time,
    encryption algorythm and secret key"""
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorith=ALGORITHM)

def verify_token(token: str):
    """sends back the decoded token data"""
    try:
        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    except jwt.JWTError:
        return None




// File: app/config/database.py
from sqlalchemy import create_engine, inspect
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "postgresql://safariconnect:1Amodung%40%21.@192.168.0.102:5432/captive_portal"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# create db
def create_database():
    #Ensuring the tables are created only once
    inspector = inspect(engine)
    if not inspector.get_table_names():  # Check if tables already exist
        print("Setting up database tables...")
        Base.metadata.create_all(bind=engine)
        print("Tables created.")

try:
    connection = engine.connect()
    print("DataBase Exists and Is connected successfully")
except Exception as e:
    print(f"Database connectio failed: {e}")

# the dependancy
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()




// File: app/config/settings.py
from pydantic import BaseSettings

# environment variables
class Settings(BaseSettings):
    mpesa_consumer_key = "O7VPs1yZAADxdI4nszyxI4lAN8IXCX2Glf0gRcNm5SgG5b48"
    mpesa_consumer_secret = "CrKa9Fu9hB65bpNKSF03ZWqCR8QdrHhvGZFjVRSRVM2Jb7ynfx7ctTtJUY0KEhKG"
    mpesa_passkey = "bfb279f9aa9bdbcf158e97dd71a467cd2e0c893059b10f78e6b72ada1ed2c919"
    mpesa_shortcode = "174379"
    callback_url = "https://f570-41-209-3-162.ngrok-free.app/payment/mpesa/callback"

    class Config:
        env_file = ".env"

settings = Settings()




// File: app/main.py
from fastapi import FastAPI, Depends, HTTPException, Request
from fastapi.security import OAuth2PasswordBearer
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from pathlib import Path
from app.config.database import create_database
from app.middleware.ip_whitelist import allow_ip_middleware
from app.routes import user, subscription, payment, mac_address
from app.auth.security import SECRET_KEY
import jwt

app = FastAPI()

# Configure templates and static files
app.mount("/static", StaticFiles(directory=Path(__file__).parent / "static"), name="static")
templates = Jinja2Templates(directory=Path(__file__).parent / "templates")

# Configure CORS settings
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Middlewares
app.middleware("http")(allow_ip_middleware)

# Routes
app.include_router(user.router, prefix="/user", tags=["User"])
app.include_router(subscription.router, prefix="/subscription", tags=["Subscription"])
app.include_router(payment.router, prefix="/Payment", tags=["Payment"])
app.include_router(mac_address.router, prefix="/mac-address", tags=["MAC Address"])

# Init Db
create_database()

# root of app
@app.get("/")
async def home(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})

# Check on the Sesion Token
# dependency function when I need a user session validated

security = OAuth2PasswordBearer(tokenUrl="token")

def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=["HS256"])
        return payload # maybe I'll return a user ID for other checks later.
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Session token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid session token")

@app.get("/protected-endpoint")
async def protected_route(user:dict = Depends(get_current_user)):
    return {"message": "Access granted", "user": user}


// File: app/middleware/ip_whitelist.py
from fastapi import Request, HTTPException

# whitelisted IP addresses
ALLOWED_CALLBACK_IPS = [
    "196.201.214.200", "196.201.214.206", "196.201.213.114",
    "196.201.214.207", "196.201.214.208", "196.201.213.44",
    "196.201.212.127", "196.201.212.138", "196.201.212.129",
    "196.201.212.136", "196.201.212.74", "196.201.212.69"
]

# allow ip to give callback to the API's
async def allow_ip_middleware(request: Request, call_next):
    if request.url.path == "/payment/mpesa/callback" and request.client.host not in ALLOWED_CALLBACK_IPS:
        raise HTTPException(status_code=403, detail="Access denied: IP not Allowed")
    return await call_next(request)




// File: app/models/otp.py
from sqlalchemy import Column, Integer, String, Float, DateTime, Boolean
from app.config.database import Base
from datetime import datetime, timezone


class OTP(Base):
    __tablename__ = "otps"
    id = Column(Integer, primary_key=True, index=True)
    phone_number = Column(String)
    otp_code = Column(String)
    created_at = Column(DateTime, default=datetime.now(timezone.utc))
    is_used = Column(Boolean, default=False)


// File: app/models/payment_record.py
from sqlalchemy import Column, Integer, String, DateTime, Float
from app.config.database import Base
from datetime import datetime, timezone


# base mode for Payment record in db
class PaymentRecord(Base):
    __tablename__ = "payment_records"
    id = Column(Integer, primary_key=True, index=True)
    checkout_id = Column(String, unique=True, index=True)  # The M-Pesa transaction ID
    subscription_id = Column(Integer)  # Links to the Subscription table
    status = Column(String, default="Pending")  # Payment status
    amount = Column(Float, nullable=True)
    mpesa_receipt_number = Column(String, nullable=True)
    transaction_date = Column(DateTime, nullable=True)
    phone_number = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.now(timezone.utc))




// File: app/models/subscription.py
from sqlalchemy import Column, Integer, String, Float, DateTime, Boolean
from app.config.database import Base

# base model for Subscription in db

class Subscription(Base):
    __tablename__ = "subscriptions"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer)
    plan_type = Column(String)
    amount = Column(Float)
    start_time = Column(DateTime)
    end_time = Column(DateTime)
    is_active = Column(Boolean, default=False)




// File: app/models/user.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean
from datetime import datetime
from app.config.database import Base

# base model for A user in db
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    phone_number = Column(String, unique=True, index=True)
    mac_address = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)
    is_active = Column(Boolean, default=True)




// File: app/routes/mac_address.py
import subprocess, platform, uuid, socket, logging, asyncio
from fastapi import APIRouter, Request

router = APIRouter()
#Get Client MAC ADDRESS

@router.post("/mac-address")
async def get_mac_address(req: Request):
    if not isinstance(req, Request):
        logging.error("Received a non-Request object.")
        return {
            "status": "error",
            "message": "Invalid request object"
        }

    try:
        print(f"Request type: {type(req)}")
        client_ip = req.client.host
        logging.info(f"Attempting to retrieve MAC for IP: {client_ip}")
        
        # if async is still waiting ...
        if asyncio.iscoroutinefunction(get_mac_from_ip):
            mac_address = await get_mac_from_ip(client_ip)
        else:
            mac_address = get_mac_from_ip(client_ip)
        
        # Check if MAC address was successfully retrieved; otherwise use fallback
        if not mac_address:
            mac_address = "00:00:00:00:00:00"  # Placeholder for unobtainable MAC
        
        return {
            "status": "success" if mac_address else "error",
            "mac_address": mac_address,
            "client_ip": client_ip
        }
    except Exception as e:
        logging.error(f"Error in MAC address endpoint: {e}")
        return {
            "status": "error",
            "message": "An unexpected error occurred",
            "client_ip": client_ip if 'client_ip' in locals() else "unknown"
        }


#############################################################################
def get_mac_from_ip(ip_address):
    """
    Attempt to retrieve MAC address for a given IP address using multiple methods.
    
    Args:
        ip_address (str): IP address to find MAC for
    
    Returns:
        str: MAC address if found, None otherwise
    """
    try:
        # Method 1: Use system-specific ARP commands
        os_system = platform.system().lower()
        
        if os_system == 'windows':
            try:
                # Windows ARP command
                result = subprocess.run(['arp', '-a', ip_address], 
                                        capture_output=True, 
                                        text=True, 
                                        timeout=5)
                # Parse ARP output to extract MAC
                for line in result.stdout.split('\n'):
                    if ip_address in line:
                        # Extract MAC address (typically in format xx-xx-xx-xx-xx-xx)
                        mac = line.split()[-1].replace('-', ':')
                        if mac and len(mac.split(':')) == 6:
                            return mac
            except Exception as e:
                logging.error(f"Windows ARP lookup failed: {e}")
        
        elif os_system in ['linux', 'darwin']:  # Linux or macOS
            try:
                # Linux/macOS ARP command
                result = subprocess.run(['arp', '-n', ip_address], 
                                        capture_output=True, 
                                        text=True, 
                                        timeout=5)
                # Parse ARP output to extract MAC
                for line in result.stdout.split('\n'):
                    if ip_address in line:
                        # Extract MAC address (typically in format xx:xx:xx:xx:xx:xx)
                        parts = line.split()
                        mac = parts[2] if len(parts) > 2 else None
                        if mac and len(mac.split(':')) == 6:
                            return mac
            except Exception as e:
                logging.error(f"Linux/macOS ARP lookup failed: {e}")
        
        # Method 2: Fallback to UUID (if above methods fail)
        # This will return a pseudo-MAC based on the system's UUID
        if ip_address == '127.0.0.1' or ip_address == '::1':
            return str(uuid.getnode())
        
        # Additional fallback: Try socket method
        try:
            hostname = socket.gethostbyaddr(ip_address)[0]
            # Attempt to get MAC via hostname (not reliable for remote IPs)
            mac = ':'.join(['{:02x}'.format((uuid.getnode() >> elements) & 0xff) 
                            for elements in range(0,2*6,2)][::-1])
            return mac
        except Exception as e:
            logging.error(f"Hostname MAC lookup failed: {e}")
        
        return None
    
    except Exception as e:
        logging.error(f"Unexpected error in get_mac_from_ip: {e}")
        return None


// File: app/routes/payment.py
from fastapi import APIRouter, Request, Depends, HTTPException
from app.models.payment_record import PaymentRecord
from app.models.subscription import Subscription
from app.config.database import get_db
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
from datetime import datetime, time
import logging, traceback, asyncio

router = APIRouter()


##########################################


##########################################
@router.post("/mpesa/callback")
async def mpesa_callback(request: Request, db: Session = Depends(get_db)):
    print("M-Pesa callback route hit\n")
    print(f"Received M-Pesa callback request\n.{request}")
    try:
        # Parse JSON payload
        stk_callback_response = await request.json()
        print(f"Parsed JSON payload: {stk_callback_response}")
        result = stk_callback_response.get('Body', {}).get('stkCallback', {})
        # Extract relevant fields from callback
        checkout_id = result.get('CheckoutRequestID')
        result_code = result.get('ResultCode')
        result_desc = result.get('ResultDesc')

        print(f"Extracted Callback Details - CheckoutID: {checkout_id}, ResultCode: {result_code}, ResultDesc: {result_desc}")
        # Check if the ResultCode indicates success
        if result_code == 0:
            logging.info("Payment is successful. Extracting metadata...")

            # Extract metadata items and ensure all fields are available
            metadata = {item['Name']: item.get('Value') for item in result.get('CallbackMetadata', {}).get('Item', [])}
            amount = metadata.get("Amount")
            receipt_number = metadata.get("MpesaReceiptNumber")
            transaction_date_str = metadata.get("TransactionDate")
            phone_number = metadata.get("PhoneNumber")
            # Log extracted metadata
            print(f"Extracted Metadata - Amount: {amount}, ReceiptNumber: {receipt_number}, TransactionDate: {transaction_date_str}, PhoneNumber: {phone_number}")
            # Validate extracted metadata fields
            if not (amount and receipt_number and transaction_date_str and phone_number):
                logging.error("Incomplete metadata in M-Pesa callback.")
                raise HTTPException(status_code=400, detail="Incomplete callback metadata")
            # Ensure `transaction_date_str` is a string, as `strptime` expects a string
            if isinstance(transaction_date_str, int):
                transaction_date_str = str(transaction_date_str)

            # Convert transaction date to datetime object
            try:
                transaction_date = datetime.strptime(transaction_date_str, "%Y%m%d%H%M%S")
            except ValueError as e:
                logging.error(f"Date parsing error: {e}")
                raise HTTPException(status_code=400, detail="Invalid date format in callback")

            # Fetch and proceed update PaymentRecord in the database if the CheckoutID was in there ro begin with
            print("Querying PaymentRecord from database.\n")
            retries = 10
            for attempt in range(retries):
                payment_record = db.query(PaymentRecord).filter(PaymentRecord.checkout_id == checkout_id).first()
                if payment_record:
                    break
                await asyncio.sleep(1)
            else:
                logging.warning(f"No PaymentRecord found for CheckoutID: {checkout_id}")
                raise HTTPException(status_code=404, detail="Payment record not found")

            print("PaymentRecord found. Updating with transaction details.")
            payment_record.amount = amount
            payment_record.mpesa_receipt_number = receipt_number
            payment_record.transaction_date = transaction_date
            payment_record.phone_number = phone_number
            payment_record.status = "Successful"
            db.commit()
            print("PaymentRecord updated and committed to database.")

            # Activate subscription
            print("Activating subscription for successful payment.")
            activated = await retry_callback_activation(checkout_id, db)
            if activated:
                print("Subscription activated successfully.")
                return {"message": "Payment processed successfully"}
        else:
            # Handle failed payment and mark as failed
            logging.info(f"Payment failed with ResultCode: {result_code}. Marking payment as failed.")
            await mark_payment_failed(checkout_id, db)
            logging.info("Payment marked as failed in database.")
            return {"message": f"Payment failed: {result_desc}"}
    except KeyError as e:
        logging.error(f"Missing field in callback data: {e}")
        raise HTTPException(status_code=400, detail="Invalid callback data format")
    except SQLAlchemyError as e:
        logging.error(f"Database error in processing callback: {e}")
        raise HTTPException(status_code=500, detail="Database error during callback processing")
    except Exception as e:
        logging.error(f"Unexpected error in callback processing: {e}")
        raise HTTPException(status_code=500, detail="Error processing callback data")


######################################
# handle retries if callback fails.
async def retry_callback_activation(checkout_id: str, db: Session, retries=100, delay=2):
    for attempt in range(retries):
        try:
            result = activate_subscription(checkout_id, db)
            if result:
                print("Subscription activated after callback.")
                return True
        except Exception as e:
            logging.error(f"Retry {attempt+1} failed: {e}")
            time.sleep(delay)
    logging.error(f"Failed to activate subscription after {retries} retries.")


def activate_subscription(checkout_id: str, db: Session):
    """Activate subscription after successful payment"""
    # Retrieve payment record
    payment_record = db.query(PaymentRecord).filter(PaymentRecord.checkout_id == checkout_id).first()
    
    if payment_record:
        # update the subscription status.
        subscription = db.query(Subscription).filter(Subscription.id == payment_record.subscription_id).first()
        if subscription:
            subscription.is_active = True
            db.commit()
            print("Subscription activated")
            return True
        else:
            logging.warning("Subscription Record Pending.. No Found in Database\n")
            raise HTTPException(status_code=400, detail="Subscription status not found on DataBasa\n")


async def mark_payment_failed(checkout_id: str, db: Session):
    """This function will mark the subscription as inactive or pending in case of payment failure."""
    # Retrieve the payment record
    payment_record = db.query(PaymentRecord).filter(PaymentRecord.checkout_id == checkout_id).first()
    
    if payment_record:
        # Update the subscription status as failed
        subscription = db.query(Subscription).filter(Subscription.id == payment_record.subscription_id).first()
        if subscription:
            subscription.is_active = False
            db.commit()
            print("Payment failed, subscription inactive")


// File: app/routes/subscription.py
from fastapi import APIRouter, Depends, Request, HTTPException
from sqlalchemy.orm import Session
from app.models.subscription import Subscription
from app.models.user import User
from app.config.database import get_db
from app.services.mpesa_services import initiate_stk_push
from app.routes.user import eat_timezone
from datetime import datetime, timedelta
import pytz, logging

router = APIRouter()

@router.post("/subscribe")
async def create_subscription(request: Request, db: Session = Depends(get_db)
):
    # Plan configurations
    plans = {
        "1hr": {"amount": 1, "duration": timedelta(hours=1)},
        "2hrs": {"amount": 25, "duration": timedelta(hours=2)},
        "3hrs": {"amount": 35, "duration": timedelta(hours=3)},
        "8hrs": {"amount": 80, "duration": timedelta(hours=8)},
        "12hrs": {"amount": 100, "duration": timedelta(hours=12)},
        "24hrs": {"amount": 150, "duration": timedelta(days=1)},
        "3 days": {"amount": 300, "duration": timedelta(days=3)},
        "1 week": {"amount": 550, "duration": timedelta(weeks=1)},
        "2 weeks": {"amount": 1000, "duration": timedelta(weeks=2)},
        "monthly": {"amount": 1750, "duration": timedelta(days=30)}
    }
    
    if request.plan_type not in plans:
        raise HTTPException(status_code=400, detail="Invalid plan type")
    
    plan = plans[request.plan_type]
    subscription = Subscription(
        user_id=request.user_id,
        plan_type=request.plan_type,
        amount=plan["amount"],
        start_time=datetime.now(eat_timezone),
        end_time=datetime.now(eat_timezone) + plan["duration"],
        is_active=False
    )
    print(f"Your subscription is \n {subscription}")
    db.add(subscription)
    db.commit()
    
    # Initiate M-Pesa payment
    response = await initiate_mpesa_payment(subscription.id, plan["amount"], db)
    
    return {"message": "Subscription initiated, payment pending", "mpesa_response": response}


#creating a subscription status checker
@router.post("/subscription-status")
async def subscription_status(user_id: int, db: Session = Depends(get_db)):
    print(f"checking subscription status for user: {user_id}")
    subscription = db.query(Subscription).filter(
        Subscription.user_id == user_id,
        Subscription.is_active == True
    ).first()
    logging.info(f"subscription for {subscription.user_id} is {subscription.is_active}\n")

    # Calculate time left in seconds if there's an active subscription
    if subscription:
        # Ensure `end_time` is timezone-aware
        if subscription.end_time.tzinfo is None:
            subscription.end_time = subscription.end_time.astimezone(eat_timezone)
        
        time_left = (subscription.end_time - datetime.now(eat_timezone)).total_seconds()
        return {"subscription_active": True, "time_left": max(time_left, 0)}
    
    # Return inactive status if no subscription found
    return {"subscription_active": False, "time_left": 0}


def initiate_mpesa_payment(subscription_id: int, amount: float, db: Session):
    # Retrieve the user's phone number from the database
    subscription = db.query(Subscription).filter(Subscription.id == subscription_id).first()
    user = db.query(User).filter(User.id == subscription.user_id).first()
    
    if not user:
        raise HTTPException(status_code=404, detail="user not found")
    
    phone_number = user.phone_number
    
    try:
        # STK PUSH INITIATE
        print("Initiating Mpesa STK Push Now")
        response = initiate_stk_push(
            phone_number=phone_number,
            amount=amount,
            reference=str(subscription_id) # unique to match with callback
        )
        logging.info(f"In the initiate_mpesa_payment call, this is the response: \n {response}")
        return response
    except Exception as e:
        print(f"Error initializing payment: {e}")
        raise HTTPException(status_code=500, detail="M-Pesa payment initiaizaion failed")


// File: app/routes/user.py
from fastapi import APIRouter, Depends, Request, HTTPException
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from app.models.user import User
from app.config.database import get_db, Base
from app.models.otp import OTP
from app.models.subscription import Subscription
from app.auth.security import SECRET_KEY, create_access_token
from pydantic import BaseModel
from datetime import datetime, timezone, timedelta
import pytz, africastalking, jwt, subprocess, logging, platform, uuid, socket

router = APIRouter()
eat_timezone = pytz.timezone("Africa/Nairobi")

africastalking.initialize(
    username='sandbox',
    api_key='atsk_2c126971a075f8c3ed0dbab580d1e4cb7959577587717d23e5fca0b6387104f4e7079690'
)
sms = africastalking.SMS


########################################
# register user
@router.post("/register")
async def register_user(request: Request, db: Session = Depends(get_db)):
    # Check if the user already exists
    existing_user = db.query(User).filter(User.phone_number == request.phone_number).first()
    if existing_user:
        # Resend OTP for the existing user
        otp_code = generate_otp()
        print(f"TOP: {otp_code}")
        store_otp(db, request.phone_number, otp_code)
        send_otp_sms(request.phone_number, otp_code)
        return {"message": "User already registered. New OTP sent for verification."}

    # If user does not exist, proceed to create a new entry
    try:
        user = User(phone_number=request.phone_number, mac_address=request.mac_address)
        db.add(user)
        db.commit()

        # Generate and send OTP for the new registration
        otp_code = generate_otp()
        print(f"TOP: {otp_code}")
        store_otp(db, request.phone_number, otp_code)
        send_otp_sms(request.phone_number, otp_code)

        return {"message": "Registration initiated. OTP sent for verification."}
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="User registration failed due to a database error.")

####################################################

# RETURNING USERS #

@router.post("/login")
async def login_user(phone_number: str, db: Session = Depends(get_db)):
    # Check if the user is registered
    user = db.query(User).filter(User.phone_number == phone_number).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not registered")

    # Generate and store OTP
    otp_code = generate_otp()
    store_otp(db, phone_number, otp_code)
    print(f"Returning OTP:{otp_code}\n")
    send_otp_sms(phone_number, otp_code)
    return {"message": "OTP sent to your phone"}


#######################################
# verify user's otp
class OtpRight (BaseModel):
    phone_number: str
    otp_code: str
@router.post("/verify-otp")
async def verify_otp(re: OtpRight, db: Session = Depends(get_db)):
    #check is OTP is valid and not used
    otp = db.query(OTP).filter(
        OTP.phone_number == re.phone_number,
        OTP.otp_code == re.otp_code,
        OTP.is_used == False
    ).first()
    
    if not otp:
        raise HTTPException(status_code=400, detail="Invalid OTP")
    
    #Then Mark It as Used
    otp.is_used = True
    db.commit()
    
    # Check if the user is registered
    user = db.query(User).filter(User.phone_number == re.phone_number).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not registered")
    
    #check for an active subscripiton.
    active_subscription = db.query(Subscription).filter(
        Subscription.user_id == user.id,
        Subscription.is_active == True,
        Subscription.end_time > datetime.now(timezone.utc)
    ).first()
    
    #if there's an active subscription, Generate a token leading to the countdown to the end of their session.
    if active_subscription:
        # Convert `end_time` to UTC if it is offset-naive
        if active_subscription.end_time.tzinfo is None:
            active_subscription.end_time = active_subscription.end_time.astimezone(eat_timezone)
        
        time_left = active_subscription.end_time - datetime.now(eat_timezone)
        
        session_data = {
            "sub": user.phone_number,
            "message": "Hey, you enjoing the Internet?",
            "subscription_active": True,
            "time_left": time_left.total_seconds(),
            "plan_type": active_subscription.plan_type,
            "user_id":user.id
        }
    # if there are no active subscriptions
    else:
        session_data = {
            "sub": user.phone_number,
            "message": "Hello, Welcome back!",
            "subscription_active": False,
            "user_id": user.id
        }
    token = create_access_token(session_data)
    return {"token": token, "message": "Well, Your Session Is still active..."}
#######################################


# Generate 6 figure OTP
def generate_otp():
    # Generate 6-digit OTP
    import random
    return str(random.randint(100000, 999999))


#Store OTP in Database
def store_otp(db: Session, phone_number: str, otp_code: str):
    otp = OTP(phone_number=phone_number, otp_code=otp_code, is_used=False, created_at=datetime.now(eat_timezone))
    db.add(otp)
    db.commit()


#Send OTP SMS
def send_otp_sms(phone_number: str, otp_code: str):
    message = f"Your OTP code is: {otp_code}"
    try:
        response = sms.send(message, [phone_number])
        return response
    except Exception as e:
        raise HTTPException(status_code=500, detail="Failed to send SMS")



def get_mac_from_ip(ip_address):
    """
    Attempt to retrieve MAC address for a given IP address using multiple methods.
    
    Args:
        ip_address (str): IP address to find MAC for
    
    Returns:
        str: MAC address if found, None otherwise
    """
    try:
        # Method 1: Use system-specific ARP commands
        os_system = platform.system().lower()
        
        if os_system == 'windows':
            try:
                # Windows ARP command
                result = subprocess.run(['arp', '-a', ip_address], 
                                        capture_output=True, 
                                        text=True, 
                                        timeout=5)
                # Parse ARP output to extract MAC
                for line in result.stdout.split('\n'):
                    if ip_address in line:
                        # Extract MAC address (typically in format xx-xx-xx-xx-xx-xx)
                        mac = line.split()[-1].replace('-', ':')
                        if mac and len(mac.split(':')) == 6:
                            return mac
            except Exception as e:
                logging.error(f"Windows ARP lookup failed: {e}")
        
        elif os_system in ['linux', 'darwin']:  # Linux or macOS
            try:
                # Linux/macOS ARP command
                result = subprocess.run(['arp', '-n', ip_address], 
                                        capture_output=True, 
                                        text=True, 
                                        timeout=5)
                # Parse ARP output to extract MAC
                for line in result.stdout.split('\n'):
                    if ip_address in line:
                        # Extract MAC address (typically in format xx:xx:xx:xx:xx:xx)
                        parts = line.split()
                        mac = parts[2] if len(parts) > 2 else None
                        if mac and len(mac.split(':')) == 6:
                            return mac
            except Exception as e:
                logging.error(f"Linux/macOS ARP lookup failed: {e}")
        
        # Method 2: Fallback to UUID (if above methods fail)
        # This will return a pseudo-MAC based on the system's UUID
        if ip_address == '127.0.0.1' or ip_address == '::1':
            return str(uuid.getnode())
        
        # Additional fallback: Try socket method
        try:
            hostname = socket.gethostbyaddr(ip_address)[0]
            # Attempt to get MAC via hostname (not reliable for remote IPs)
            mac = ':'.join(['{:02x}'.format((uuid.getnode() >> elements) & 0xff) 
                            for elements in range(0,2*6,2)][::-1])
            return mac
        except Exception as e:
            logging.error(f"Hostname MAC lookup failed: {e}")
        
        return None
    
    except Exception as e:
        logging.error(f"Unexpected error in get_mac_from_ip: {e}")
        return None
    


// File: app/schemas/payment.py
from pydantic import BaseModel

class PaymentCallback(BaseModel):
    checkout_id: str
    status: str
    amount: float




// File: app/schemas/subscription.py
from pydantic import BaseModel

class SubscriptionCreate(BaseModel):
    user_id: int
    plan_type: str




// File: app/schemas/user.py
from pydantic import BaseModel

class UserCreate(BaseModel):
    phone_number: str
    mac_address: str




// File: app/services/mpesa_services.py
import requests
from app.config.settings import settings
from datetime import datetime, timedelta
from fastapi import Depends, HTTPException
from app.config.database import get_db
from app.models.payment_record import PaymentRecord
from app.config.settings import settings
from sqlalchemy.orm import Session
from sqlalchemy import engine
from datetime import datetime
from sqlalchemy.orm import Session, sessionmaker
import logging, json, base64, time

async def initiate_stk_push(phone_number: str, amount: float, reference: str, db: Session = Depends(get_db)):
        """Initiate STK push to customer's phone"""
        #phone number formating for safaricom API
        if phone_number.startswith("+"):
            phone_number = phone_number[1:]  # Remove leading '+'
        elif phone_number.startswith("0"):
            phone_number = f"254{phone_number[1:]}"  # Convert '0' to '254'
            
        access_token = await get_access_token()
        password, timestamp = generate_password()
        
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {access_token}",
        }
        
        payload = {
            "BusinessShortCode": settings.mpesa_shortcode,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": int(amount),
            "PartyA": phone_number,
            "PartyB": settings.mpesa_shortcode,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.callback_url,
            "AccountReference": f"Safari Connect. Session_ID: {reference}",
            "TransactionDesc": f"Payment for internet Subscription"
        }
        
        logging.info(f"Payload sent to M-Pesa: {json.dumps(payload, indent=4)}")
        
        try:
            response = requests.post(settings.callback_url, headers=headers, json=payload)
            
            if response.status_code != 200:
                logging.error(f"M-Pesa API Error: {response.status_code} - {response.text}")
                raise HTTPException(status_code=400, detail="Failed to initiate payment")
            
            # Log the successful response
            print(f"M-Pesa Response: {response.json()}")
            
            #store data
            response_data = response.json()
            checkout_id = response_data.get('CheckoutRequestID')
            
            if not checkout_id:
                logging.error("No CheckoutRequestID in M-Pesa response.")
                raise HTTPException(status_code=400, detail="Missing checkout ID in M-Pesa response.")
            
            subscription_id = int(reference)
            
            #STORE IT
            storeed = store_checkout_request(checkout_id, subscription_id, db)
            if storeed:
                print(f"PaymentRecord stored successfully for CheckoutID: {checkout_id}")
            else:
                logging.error(f"Failed To store Checkot Requestfor CheckoutReaquestID: {checkout_id}")
                raise HTTPException(status_code=400, detail="Failed to store Checkout ID in database")
            
            return response_data
        
        except Exception as e:
            logging.error(f"Error initializing M-Pesa payment: {e}")
            raise HTTPException(status_code=500, detail="M-Pesa payment initialization failed")


#########################################


def generate_password(self):
        """Generate the M-Pesa password using the provided passkey"""
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        data_to_encode = f"{settings.mpesa_shortcode}{settings.mpesa_passkey}{timestamp}"
        return base64.b64encode(data_to_encode.encode()).decode('utf-8'), timestamp


#########################################


async def get_access_token():
        """Get the access token required to make M-Pesa API calls"""
        if access_token and datetime.now() < access_token_expiry:
            return access_token

        credentials = base64.b64encode(
            f"{settings.mpesa_consumer_key}:{settings.mpesa_consumer_secret}".encode()
        ).decode('utf-8')

        response = requests.get(
            "https://sandbox.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials",
            headers={"Authorization": f"Basic {credentials}"}
        )

        if response.status_code != 200:
            raise HTTPException(status_code=400, detail="Failed to get access token")

        result = response.json()
        access_token = result['access_token']
        # Token expires in 1 hour
        access_token_expiry = datetime.now() + timedelta(seconds=3599)
        return access_token


############################################
def store_checkout_request(checkout_id: str, subscription_id: int, db: Session):
    """When initiating an M-Pesa transaction, you will receive a CheckoutRequestID that serves as a unique identifier.
    Store this ID and subscription_id in the database to verify payment status later."""
    
    SessionLocal = sessionmaker(autocommit=False, bind=engine)
    db = SessionLocal()
    
    print(f"Storing checkout request - CheckoutID: {checkout_id}, SubscriptionID: {subscription_id}")
    
    try:
        payment_record = PaymentRecord(
            checkout_id=checkout_id,
            subscription_id=subscription_id,
            status="Pending"  # Initial status
        )
        db.add(payment_record)
        db.commit()  # Ensure async commit
        db.refresh(payment_record)
        print("Payment stored successfully")
        
        return True
    except Exception as e:
        print(f"Failed to store checkout request: {e}")
        raise HTTPException(status_code=500, detail="Failed to store payment record.")
    finally:
        db.close()


// File: app/static/index.js
const API_BASE_URL = 'http://192.168.0.102:8000';
let selectedPlan = null;
let currentUser = null;
let paymentStatusInterval = null;
let countdownInterval = null;

document.addEventListener('DOMContentLoaded', () => {
    const token = localStorage.getItem('authToken');
    const path = window.location.pathname;

    if (token) {
        const decodedToken = decodeJwt(token);

        // Check if token is expired
        if (isTokenExpired(decodedToken)) {
            localStorage.removeItem('authToken');
            window.location.href = '/otp-verification';
        } else {
            currentUser = decodedToken;
            
            // Check subscription status and redirect accordingly
            if (currentUser.subscription_active) {
                window.location.href = '/countdown';
            } else {
                window.location.href = '/subscription-success';
            }
        }
    } else {
        // Handle paths if no token
        if (path === "/") {
            initRegisterPage();
        } else if (path === "/otp-verification") {
            initOTPPage();
        } else if (path === "/subscription-success") {
            initSubscriptionPage();
        }
    }
});

// Utility: Decode JWT to Access Session Data
function decodeJwt(token) {
    try {
        const base64Url = token.split('.')[1];
        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
        return JSON.parse(atob(base64));
    } catch (error) {
        console.error("Invalid token format", error);
        return null;
    }
}

// Utility: Check if Token is Expired
function isTokenExpired(decodedToken) {
    if (!decodedToken || !decodedToken.exp) return true;
    const currentTime = Math.floor(Date.now() / 1000); // Current time in seconds
    return decodedToken.exp < currentTime;
}

// Helper to get auth headers with token
function getAuthHeaders() {
    const token = localStorage.getItem('authToken');
    if (!token) {
        window.location.href = '/otp-verification';
        return null;
    }
    return { headers: { Authorization: `Bearer ${token}` } };
}

// 1. Registration and MAC Retrieval
async function initRegisterPage() {
    document.querySelector('form').addEventListener('submit', async (event) => {
        event.preventDefault();
        const phone = document.getElementById('phone').value;
        const macAddress = await getMacAddress();

        try {
            const response = await axios.post(`${API_BASE_URL}/user/register`, { phone_number: phone, mac_address: macAddress });
            showSuccess(response.data.message || "Registered successfully");
            window.location.href = '/otp-verification';
        } catch (error) {
            showError("Registration failed. Please try again.");
        }
    });
}

// Get MAC Address from backend
async function getMacAddress() {
    try {
        const response = await axios.get(`${API_BASE_URL}/mac_address/mac-address`);
        return response.data.mac_address || "MAC not found";
    } catch (error) {
        console.error("Failed to retrieve MAC address:", error);
        return "Error retrieving MAC";
    }
}

// 2. OTP Verification and Store Token
async function initOTPPage() {
    document.querySelector('form').addEventListener('submit', async (event) => {
        event.preventDefault();
        const otp = document.getElementById('otp').value;
        const phone = document.getElementById('phone').value;

        try {
            const response = await axios.post(`${API_BASE_URL}/user/verify-otp`, { phone_number: phone, otp_code: otp });
            const { token, user } = response.data;
            if (token) {
                localStorage.setItem('authToken', token);  // Save token to keep user logged in
                showSuccess(response.data.message || "OTP verified successfully");
                currentUser = decodeJwt(token);
                window.location.href = currentUser.subscription_active ? '/countdown' : '/subscription-success';
            }
        } catch (error) {
            showError("Invalid OTP. Please try again.");
        }
    });
}

// 3. Subscription Page Initialization
function initSubscriptionPage() {
    document.querySelectorAll('.plan-card').forEach(card => {
        card.addEventListener('click', (event) => selectPlan(event, card.getAttribute('data-plan')));
    });
    document.getElementById('subscribeBtn').addEventListener('click', subscribe);
}

// Subscription Plan Selection
function selectPlan(event, plan) {
    selectedPlan = plan;
    document.querySelectorAll('.plan-card').forEach(card => card.classList.remove('selected'));
    event.currentTarget.classList.add('selected');
    document.getElementById('subscribeBtn').classList.remove('hidden');
}

// 4. Subscribe to Plan with Authenticated Request
async function subscribe() {
    if (!selectedPlan) {
        showError("Please select a subscription plan.");
        return;
    }
    if (!currentUser || !currentUser.user_id) {
        showError("User information is missing. Please verify your OTP.");
        return;
    }
    try {
        const response = await axios.post(
            `${API_BASE_URL}/subscription`,
            { user_id: currentUser.user_id, plan_type: selectedPlan },
            getAuthHeaders()
        );
        showSuccess(response.data.message || "Subscription initiated. Please complete payment on your phone.");
        startPaymentStatusPolling();
    } catch (error) {
        showError("Subscription failed. Please try again.");
    }
}

// 5. Poll Payment Status until Successful
async function checkPaymentStatus() {
    try {
        const response = await axios.get(`${API_BASE_URL}/subscription-status`, { params: { user_id: currentUser.user_id } });
        if (response.data.subscription_active) {
            clearInterval(paymentStatusInterval);
            showSuccess("Payment successful. Subscription activated!");
            showSessionCountdown(response.data.time_left);
        } else {
            console.log("Payment still processing...");
        }
    } catch (error) {
        console.error("Error checking payment status:", error);
    }
}

// Start Polling for Payment Status
function startPaymentStatusPolling() {
    if (paymentStatusInterval) clearInterval(paymentStatusInterval);
    paymentStatusInterval = setInterval(checkPaymentStatus, 5000);
}

// 6. Show Session Countdown Timer
function showSessionCountdown(timeLeft) {
    const countdownContainer = document.createElement('div');
    countdownContainer.className = 'countdown-container';
    document.querySelector('.container').innerHTML = '';
    document.querySelector('.container').appendChild(countdownContainer);

    countdownContainer.innerHTML = `
        <div class="countdown-container-message">
            <h3>Tik Tok <br> Goes The Clock</h3>
            <p>Enjoy The Internet :)</p>
        </div>
    `;
    
    const timerText = document.createElement('p');
    timerText.className = 'timer-text';
    countdownContainer.appendChild(timerText);

    const buyMore = document.createElement('button');
    buyMore.className = 'buy-more-button';
    buyMore.textContent = "Buy More Time";
    countdownContainer.appendChild(buyMore);

    buyMore.addEventListener('click', () => {
        window.location.href = '/subscription-success';
    });

    function updateCountdown() {
        if (timeLeft <= 0) {
            clearInterval(countdownInterval);
            countdownContainer.innerHTML = "<p>Session expired. Please select a plan.</p>";
            document.getElementById('subscribeBtn').classList.remove('hidden');
            return;
        }

        const hours = Math.floor(timeLeft / 3600);
        const minutes = Math.floor((timeLeft % 3600) / 60);
        const seconds = Math.floor(timeLeft % 60);
        timerText.textContent = `Session time left: ${hours}h ${minutes}m ${seconds}s`;
        timeLeft--;
    }

    countdownInterval = setInterval(updateCountdown, 1000);
    updateCountdown();
}

// Utility Functions for Error/Success Messages
function showError(message) {
    const error = document.createElement('div');
    error.className = 'error';
    error.textContent = message;
    document.querySelector('.container').appendChild(error);
    setTimeout(() => error.remove(), 3000);
}

function showSuccess(message) {
    const success = document.createElement('div');
    success.className = 'success';
    success.textContent = message;
    document.querySelector('.container').appendChild(success);
    setTimeout(() => success.remove(), 3000);
}



// File: app/static/style.css
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
}

body {
    background: #f0f2f5;
    color: #1a1a1a;
    line-height: 1.6;
}

.titlename{
    padding-top: 2rem;
}
.page-container {
    position: relative;
    min-height: 100vh;
}

main {
    padding-bottom: 2rem;
}

/* Header and Footer Styling */
#footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 3rem;
    background-color: #1a73e8;
    color: white;
    padding: 1rem;
    text-align: center;
}

/* Container Styling */
.container {
    max-width: 400px;
    margin: 2rem auto;
    padding: 2rem;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    text-align: center;
}

.contdown-container {
    max-width: 400px;
    margin: 2rem auto;
    padding: 1rem;
}

h1, h2, h3 {
    text-align: center;
    color: #1a73e8;
    margin-bottom: 1rem;
}

/*form and input styling*/
label {
    display: block;
    margin: 1rem 0 0.5rem;
    text-align:center;
    color: #666;
}

form {
    text-align: center;
}
input[type="tel"], input[type="text"] {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 1rem;
    margin-bottom: 1rem;
    text-align: center;
}

/*button styling*/
button {
    width: 100%;
    padding: 0.75rem;
    background: #1a73e8;
    color: white;
    border: none;
    border-radius: 4px;
    font-size: 1rem;
    cursor: pointer;
    transition: background 0.3s;
}

button:hover {
    background: #1557b0;
}

a {
    color: #1a73e8;
    text-decoration: none;
    display: inline-block;
    margin-top: 1rem;
}

/* Error and Success Message */
.error {
    color: #d93025;
    margin-top: 0.5rem;
    font-size: 0.875rem;
}

.success {
    color: #188038;
    margin-top: 0.5rem;
    font-size: 0.875rem;
}

/******************************************************/
.card, .card3 {
    background: white;
    border-radius: 8px;
    padding: 2rem;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    text-align: center;
}

.card3 {
    margin-top: 10px;
}

.form-group {
    margin-bottom: 1rem;
}



.plans {
    display: grid;
    gap: 1rem;
    margin-top: 1rem;
}

.plan-card {
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 1rem;
    cursor: pointer;
    transition: all 0.3s;
}

.plan-card:hover {
    border-color: #1a73e8;
    transform: translateY(-2px);
}

.plan-card.selected {
    border-color: #1a73e8;
    background: #f8f9fe;
}



.hidden {
    display:none;
}

.icon-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: fit-content;
}

.safari-icon {
    height: 200px;
}


// File: app/templates/base.html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>{% block title %}Safari Connect Portal{% endblock %}</title>
        <link rel="stylesheet" href="/static/style.css" />
        <link
        rel="shortcut icon"
        href="/static/resources/safari-icon2.svg"
        type="image/x-icon"
        />
    </head>
    <body>
        <div class="page-container">
            <main>{% block content %}{% endblock %}</main>

            <footer id="footer">
                <p>&copy; 2024 Safari Connect</p>
            </footer>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.2/axios.min.js"></script>
        <script src="/static/index.js"></script>
    </body>
</html>



// File: app/templates/index.html
{% extends "base.html" %}

{% block title %}Safari Connect - Welcome{% endblock %}

{% block content %}
{% include "logo.html" %}
<div class="container">
    <p>Register to enjoy our internet services.</p>

    <form>
        <label for="phone">Phone Number</label>
        <input type="tel" id="phone" name="phone_number" placeholder="+254 XXXXXX" required>
        <button type="submit">Login</button>
    </form>
</div>
{% endblock %}


// File: app/templates/logo.html
<h1 class="titlename">Safari Connect</h1>
<div class="icon-container">
    <img class="safari-icon" src="/static/resources/safari-icon2.svg" alt="safari connect">
</div>
<p style="align-self: center; text-align: center; font-size: medium; font-weight: 300;font-style:italic; font-family: Arial, Helvetica, sans-serif;">
    Explore A Universe Of Possibilities</p>


// File: app/templates/otp_verification.html
{% extends "base.html" %}

{% block title %}Safari Connect - OTP Verification{% endblock %}

{%block content%}
<div class="container">
    {% include "logo.html" %}
    <h2>OTP Verification</h2>
    <p>Please enter the OTP sent to your phonr to compete verification.</p>

    <form>
        <label for="otp">OTP Code:</label>
        <input type="text" id="otp" name="otp_code" placeholder="Enter OTP code" required>
        <button type="submit">Verify OTP</button>
    </form>
</div>
{% endblock %}



// File: app/templates/subscription_expired.html
{% extends "base.html" %}

{% block title %}Safari Connect - Subscription Expired{% endblock %}

{% block content %}
<div class="container">
    {% include "logo.html" %}
    <h2>Subscription Expired</h2>
    <p>Your subscription has expired. Please renew to continue enjoying our services.</p>
    <a href="/" class="button-link">Return to Home</a>
</div>
{% endblock %}




// File: app/templates/subscription_success.html
{% extends "base.html" %}

{% block title %}Safari Connect - Subscription Plans{% endblock %}

{% block content %}
<div class="container">
    {% include "logo.html" %}
    <h2>Select a Subscription Plan</h2>
    <p>Choose a plan to continue enjoying internet services.</p>

    <div class="plans">
        <div class="plan-card" data-plan="1hr">
            <h3>1 Hour</h3>
            <p>KSh 10</p>
        </div>
        <div class="plan-card" data-plan="2hrs">
            <h3>2 Hours</h3>
            <p>KSh 20</p>
        </div>
        <div class="plan-card" data-plan="3hrs">
            <h3>3 Hours</h3>
            <p>KSh 30</p>
        </div>
        <div class="plan-card" data-plan="8hrs">
            <h3>8 Hours</h3>
            <p>KSh 80</p>
        </div>
        <div class="plan-card" data-plan="12hrs">
            <h3>12 Hours</h3>
            <p>KSh 100</p>
        </div>
        <div class="plan-card" data-plan="24hrs">
            <h3>24 Hours</h3>
            <p>KSh 150</p>
        </div>
        <div class="plan-card" data-plan="3 days">
            <h3>3 Days</h3>
            <p>KSh 300</p>
        </div>
        <div class="plan-card" data-plan="1 week">
            <h3>1 Week</h3>
            <p>KSh 550</p>
        </div>
        <div class="plan-card" data-plan="2 weeks">
            <h3>2 Weeks</h3>
            <p>KSh 1000</p>
        </div>
        <div class="plan-card" data-plan="monthly">
            <h3>Monthly</h3>
            <p>KSh 1750</p>
        </div>
    </div>
    <button id="subscribeBtn" class="hidden">Subscribe</button>
</div>
{% endblock %}



// File: OpenWRT/dhcp
# /etc/config/dhcp
config dnsmasq
    option domainneeded '1'
    option boguspriv '1'
    option filterwin2k '0'
    option localise_queries '1'
    option rebind_protection '1'
    option rebind_localhost '1'
    option local '/lan/'
    option domain 'lan'
    option expandhosts '1'
    option nonegcache '0'
    option authoritative '1'
    option readethers '1'
    option leasefile '/tmp/dhcp.leases'
    option resolvfile '/tmp/resolv.conf.auto'

config dhcp 'lan'
    option interface 'lan'
    option start '100'
    option limit '150'
    option leasetime '12h'


// File: OpenWRT/firewll
# Firewall rules (/etc/config/firewall)
# Allow access to captive portal
config rule
    option name 'Allow-Captive-Portal'
    option src 'lan', 'wlan', 'wan'
    option dest_port '8000'
    option proto 'tcp'
    option target 'ACCEPT'

# Block all other traffic for unauthenticated users
config rule
    option name 'Block-Unauthenticated'
    option src 'lan'
    option proto 'all'
    option target 'DROP'

# Config for Mpesa Callback IPS Whitelist
config rule
    option name 'Allow-Mpesa-Callback-1'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.214.200'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-2'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.214.206'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-3'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.213.114'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-4'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'        
    option src_ip '196.201.214.207'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-5'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.214.208'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-6'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.213.44'
    option target 'ACCEPT'
    
config rule
    option name 'Allow-Mpesa-Callback-7'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'             
    option src_ip '196.201.212.127'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-8'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.212.138'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-9'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.212.129'
    option target 'ACCEPT'
    
config rule
    option name 'Allow-Mpesa-Callback-10'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102' 
    option dest_port '8000'              
    option src_ip '196.201.212.136'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-11'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.212.74'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-12'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.212.69'
    option target 'ACCEPT'




// File: OpenWRT/network
# /etc/config/network
config interface 'loopback' # type: ignore
    option device 'lo' # type: ignore
    option proto 'static' # type: ignore
    option ipaddr '127.0.0.1' # type: ignore
    option netmask '255.0.0.0' # type: ignore

config interface 'lan' # type: ignore
    option device 'eth0' # type: ignore
    option proto 'static' # type: ignore
    option ipaddr '192.168.1.1' # type: ignore
    option netmask '255.255.255.0' # type: ignore


// File: OpenWRT/nodogsplash
# /etc/config/nodogsplash
config nodogsplash
    option enabled '1'
    option gatewayname 'WiFi Hotspot'
    option gatewayinterface 'br-lan'
    option maxclients '250'
    option clientidletimeout '1440'
    option webroot '/etc/nodogsplash/htdocs'
    option redirecturl 'http://your-portal-url'
    
# Authentication script
option authenticateimmediately '0'
option passwordattempts '5'
option gatewayiprange '192.168.1.0/24'


// File: requirements.txt
fastapi
uvicorn
sqlalchemy
psycopg2-binary
africastalking
jwt


