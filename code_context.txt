// File: Backend/captive/CaptivePortalAPI.py
from fastapi.middleware.cors import CORSMiddleware
from fastapi import FastAPI, HTTPException, Depends, Request, security
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from datetime import datetime, timedelta, timezone
from Backend.Payment.payment import app as payment_app
from Backend.Payment.payment import MPESAPayment
from Backend.database.dataBase import get_db, Subscription, User, OTP
from typing import Optional
from pydantic import BaseModel
import random, socket, platform, uuid, logging
import requests, jwt, subprocess, sys, os, asyncio
import africastalking, pytz

app = FastAPI()
security = HTTPBearer
eat_timezone = pytz.timezone("Africa/Nairobi")

app.mount("/payment", payment_app)
logging.info("Payment app mounted at /payment")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Specify your allowed origins in production
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allow_headers=["*"],
    expose_headers=["*"]
)

S_KEY = "93f2d9b13fe90325b803bf2e8f9a66d205f3ff671990ac11423183d334d86691"


# Africa's Talking SMS configuration
africastalking.initialize(
    username='sandbox',
    api_key='atsk_2c126971a075f8c3ed0dbab580d1e4cb7959577587717d23e5fca0b6387104f4e7079690'
)
sms = africastalking.SMS

# TIMEZONE EAST AFRICA

##########################################################################################

# Routes

@app.get("/")
async def root():
    return {
        "name": "Safari Connect Captive Portal API",
        "version": "1.0.0"
    }

############################################

# Check on the Sesion Token
# dependency function when I need a user session validated
def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    try:
        payload = jwt.decode(credentials.credentials, S_KEY, algorithms=["HS256"])
        return payload # maybe I'll return a user ID for other checks later.
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Session token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid session token")

@app.get("/protected-endpoint")
async def protected_route(user:dict = Depends(get_current_user)):
    return {"message": "Access granted", "user": user}

############################################

#Get Client MAC ADDRESS

@app.get("/mac-address")
async def get_mac_address(req: Request):
    if not isinstance(req, Request):
        logging.error("Received a non-Request object.")
        return {
            "status": "error",
            "message": "Invalid request object"
        }

    try:
        print(f"Request type: {type(req)}")
        client_ip = req.client.host
        logging.info(f"Attempting to retrieve MAC for IP: {client_ip}")
        
        # if async is still waiting ...
        if asyncio.iscoroutinefunction(get_mac_from_ip):
            mac_address = await get_mac_from_ip(client_ip)
        else:
            mac_address = get_mac_from_ip(client_ip)
        
        # Check if MAC address was successfully retrieved; otherwise use fallback
        if not mac_address:
            mac_address = "00:00:00:00:00:00"  # Placeholder for unobtainable MAC
        
        return {
            "status": "success" if mac_address else "error",
            "mac_address": mac_address,
            "client_ip": client_ip
        }
    except Exception as e:
        logging.error(f"Error in MAC address endpoint: {e}")
        return {
            "status": "error",
            "message": "An unexpected error occurred",
            "client_ip": client_ip if 'client_ip' in locals() else "unknown"
        }

######################################

# model for the registration request
class RegisterRequest(BaseModel):
    phone_number: str
    mac_address: str

@app.post("/register")
async def register_user(request: RegisterRequest, db: Session = Depends(get_db)):
    # Check if the user already exists
    existing_user = db.query(User).filter(User.phone_number == request.phone_number).first()
    if existing_user:
        # Resend OTP for the existing user
        otp_code = generate_otp()
        print(f"TOP: {otp_code}")
        store_otp(db, request.phone_number, otp_code)
        send_otp_sms(request.phone_number, otp_code)
        return {"message": "User already registered. New OTP sent for verification."}
    
    # If user does not exist, proceed to create a new entry
    try:
        user = User(phone_number=request.phone_number, mac_address=request.mac_address)
        db.add(user)
        db.commit()
        
        # Generate and send OTP for the new registration
        otp_code = generate_otp()
        print(f"TOP: {otp_code}")
        store_otp(db, request.phone_number, otp_code)
        send_otp_sms(request.phone_number, otp_code)
        
        return {"message": "Registration initiated. OTP sent for verification."}
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="User registration failed due to a database error.")



#######################################

class OtpRight (BaseModel):
    phone_number: str
    otp_code: str

# Endpointto verify OTP
@app.post("/verify-otp")
async def verify_otp(re: OtpRight, db: Session = Depends(get_db)):
    #check is OTP is valid and not used
    otp = db.query(OTP).filter(
        OTP.phone_number == re.phone_number,
        OTP.otp_code == re.otp_code,
        OTP.is_used == False
    ).first()
    
    if not otp:
        raise HTTPException(status_code=400, detail="Invalid OTP")
    
    #Then Mark It as Used
    otp.is_used = True
    db.commit()
    
    # Check if the user is registered
    user = db.query(User).filter(User.phone_number == re.phone_number).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not registered")
    
    #check for an active subscripiton.
    active_subscription = db.query(Subscription).filter(
        Subscription.user_id == user.id,
        Subscription.is_active == True,
        Subscription.end_time > datetime.now(timezone.utc)
    ).first()

    #if there's an active subscription, Generate a token leading to the countdown to the end of their session.
    if active_subscription:
        # Convert `end_time` to UTC if it is offset-naive
        if active_subscription.end_time.tzinfo is None:
            active_subscription.end_time = active_subscription.end_time.astimezone(eat_timezone)
        
        time_left = active_subscription.end_time - datetime.now(eat_timezone)
        
        session_data = {
            "sub": user.phone_number,
            "message": "Hey, you enjoing the Internet?",
            "subscription_active": True,
            "time_left": time_left.total_seconds(),
            "plan_type": active_subscription.plan_type,
            "user_id":user.id
        }
    # if there are no active subscriptions
    else:
        session_data = {
            "sub": user.phone_number,
            "message": "Hello, Welcome back!",
            "subscription_active": False,
            "user_id": user.id
        }
    token = create_access_token(session_data)
    return {"token": token, "message": "Well, Your Session Is still active..."}



#########################################################
# Base for subscription request components
class SubRequest (BaseModel):
    user_id: int
    plan_type: str

# Endpoint for Subscription Creation
@app.post("/subscribe")
async def create_subscription(request: SubRequest, db: Session = Depends(get_db)
):
    # Plan configurations
    plans = {
        "1hr": {"amount": 1, "duration": timedelta(hours=1)},
        "2hrs": {"amount": 25, "duration": timedelta(hours=2)},
        "3hrs": {"amount": 35, "duration": timedelta(hours=3)},
        "8hrs": {"amount": 80, "duration": timedelta(hours=8)},
        "12hrs": {"amount": 100, "duration": timedelta(hours=12)},
        "24hrs": {"amount": 150, "duration": timedelta(days=1)},
        "3 days": {"amount": 300, "duration": timedelta(days=3)},
        "1 week": {"amount": 550, "duration": timedelta(weeks=1)},
        "2 weeks": {"amount": 1000, "duration": timedelta(weeks=2)},
        "monthly": {"amount": 1750, "duration": timedelta(days=30)}
    }
    
    if request.plan_type not in plans:
        raise HTTPException(status_code=400, detail="Invalid plan type")
    
    plan = plans[request.plan_type]
    subscription = Subscription(
        user_id=request.user_id,
        plan_type=request.plan_type,
        amount=plan["amount"],
        start_time=datetime.now(eat_timezone),
        end_time=datetime.now(eat_timezone) + plan["duration"],
        is_active=False
    )
    print(f"Your subscription is \n {subscription}")
    db.add(subscription)
    db.commit()
    
    # Initiate M-Pesa payment
    response = await initiate_mpesa_payment(subscription.id, plan["amount"], db)
    
    return {"message": "Subscription initiated, payment pending", "mpesa_response": response}

##################################################

#creating a subscription status checker
@app.get("/subscription-status")
async def subscription_status(user_id: int, db: Session = Depends(get_db)):
    print(f"checking subscription status for user: {user_id}")
    subscription = db.query(Subscription).filter(
        Subscription.user_id == user_id,
        Subscription.is_active == True
    ).first()
    logging.info(f"subscription for {subscription.user_id} is {subscription.is_active}\n")

    # Calculate time left in seconds if there's an active subscription
    if subscription:
        # Ensure `end_time` is timezone-aware
        if subscription.end_time.tzinfo is None:
            subscription.end_time = subscription.end_time.astimezone(eat_timezone)
        
        time_left = (subscription.end_time - datetime.now(eat_timezone)).total_seconds()
        return {"subscription_active": True, "time_left": max(time_left, 0)}
    
    # Return inactive status if no subscription found
    return {"subscription_active": False, "time_left": 0}


####################################################

# RETURNING USERS #

@app.post("/login")
async def login_user(phone_number: str, db: Session = Depends(get_db)):
    # Check if the user is registered
    user = db.query(User).filter(User.phone_number == phone_number).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not registered")

    # Generate and store OTP
    otp_code = generate_otp()
    store_otp(db, phone_number, otp_code)
    send_otp_sms(phone_number, otp_code)
    return {"message": "OTP sent to your phone"}

#################################################################################################

#### FUNCTIONS ####



# Generate 6 figure OTP
def generate_otp():
    # Generate 6-digit OTP
    import random
    return str(random.randint(100000, 999999))


#Store OTP in Database
def store_otp(db: Session, phone_number: str, otp_code: str):
    otp = OTP(phone_number=phone_number, otp_code=otp_code, is_used=False, created_at=datetime.now(eat_timezone))
    db.add(otp)
    db.commit()


#Send OTP SMS
def send_otp_sms(phone_number: str, otp_code: str):
    message = f"Your OTP code is: {otp_code}"
    try:
        response = sms.send(message, [phone_number])
        return response
    except Exception as e:
        raise HTTPException(status_code=500, detail="Failed to send SMS")


#Create an Access Token
def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.now(eat_timezone) + timedelta(hours=1)  # Expiry as needed
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, S_KEY, algorithm="HS256")
    return encoded_jwt



#Initialize Mpesa Payment
def initiate_mpesa_payment(subscription_id: int, amount: float, db: Session):
    # Retrieve the user's phone number from the database
    subscription = db.query(Subscription).filter(Subscription.id == subscription_id).first()
    user = db.query(User).filter(User.id == subscription.user_id).first()
    
    if not user:
        raise HTTPException(status_code=404, detail="user not found")
    
    phone_number = user.phone_number
    mpesa_payment = MPESAPayment()
    
    try:
        # STK PUSH INITIATE
        print("Initiating Mpesa STK Push Now")
        response = mpesa_payment.initiate_stk_push(
            phone_number=phone_number,
            amount=amount,
            reference=str(subscription_id) # unique to match with callback
        )
        logging.info(f"In the initiate_mpesa_payment call, this is the response: \n {response}")
        return response
    except Exception as e:
        print(f"Error initializing payment: {e}")
        raise HTTPException(status_code=500, detail="M-Pesa payment initiaizaion failed")


def get_mac_from_ip(ip_address):
    """
    Attempt to retrieve MAC address for a given IP address using multiple methods.
    
    Args:
        ip_address (str): IP address to find MAC for
    
    Returns:
        str: MAC address if found, None otherwise
    """
    try:
        # Method 1: Use system-specific ARP commands
        os_system = platform.system().lower()
        
        if os_system == 'windows':
            try:
                # Windows ARP command
                result = subprocess.run(['arp', '-a', ip_address], 
                                        capture_output=True, 
                                        text=True, 
                                        timeout=5)
                # Parse ARP output to extract MAC
                for line in result.stdout.split('\n'):
                    if ip_address in line:
                        # Extract MAC address (typically in format xx-xx-xx-xx-xx-xx)
                        mac = line.split()[-1].replace('-', ':')
                        if mac and len(mac.split(':')) == 6:
                            return mac
            except Exception as e:
                logging.error(f"Windows ARP lookup failed: {e}")
        
        elif os_system in ['linux', 'darwin']:  # Linux or macOS
            try:
                # Linux/macOS ARP command
                result = subprocess.run(['arp', '-n', ip_address], 
                                        capture_output=True, 
                                        text=True, 
                                        timeout=5)
                # Parse ARP output to extract MAC
                for line in result.stdout.split('\n'):
                    if ip_address in line:
                        # Extract MAC address (typically in format xx:xx:xx:xx:xx:xx)
                        parts = line.split()
                        mac = parts[2] if len(parts) > 2 else None
                        if mac and len(mac.split(':')) == 6:
                            return mac
            except Exception as e:
                logging.error(f"Linux/macOS ARP lookup failed: {e}")
        
        # Method 2: Fallback to UUID (if above methods fail)
        # This will return a pseudo-MAC based on the system's UUID
        if ip_address == '127.0.0.1' or ip_address == '::1':
            return str(uuid.getnode())
        
        # Additional fallback: Try socket method
        try:
            hostname = socket.gethostbyaddr(ip_address)[0]
            # Attempt to get MAC via hostname (not reliable for remote IPs)
            mac = ':'.join(['{:02x}'.format((uuid.getnode() >> elements) & 0xff) 
                            for elements in range(0,2*6,2)][::-1])
            return mac
        except Exception as e:
            logging.error(f"Hostname MAC lookup failed: {e}")
        
        return None
    
    except Exception as e:
        logging.error(f"Unexpected error in get_mac_from_ip: {e}")
        return None



// File: Backend/captive/SKey.py
import secrets

# Generate a 32-byte hex key for strong security
secret_key = secrets.token_hex(32)
print(secret_key)



// File: Backend/database/dataBase.py
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, inspect
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from datetime import datetime, timezone

Base = declarative_base()

# Database Models
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    phone_number = Column(String, unique=True, index=True)
    mac_address = Column(String)
    created_at = Column(DateTime, default=datetime.now(timezone.utc))
    is_active = Column(Boolean, default=True)

class Subscription(Base):
    __tablename__ = "subscriptions"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer)
    plan_type = Column(String)  # '1hr', '2hrs', '5hrs', 'monthly'
    amount = Column(Float)
    start_time = Column(DateTime)
    end_time = Column(DateTime)
    is_active = Column(Boolean, default=True)

class OTP(Base):
    __tablename__ = "otps"
    id = Column(Integer, primary_key=True, index=True)
    phone_number = Column(String)
    otp_code = Column(String)
    created_at = Column(DateTime, default=datetime.now(timezone.utc))
    is_used = Column(Boolean, default=False)

class PaymentRecord(Base):
    __tablename__ = "payment_records"
    id = Column(Integer, primary_key=True, index=True)
    checkout_id = Column(String, unique=True, index=True)  # The M-Pesa transaction ID
    subscription_id = Column(Integer)  # Links to the Subscription table
    status = Column(String, default="Pending")  # Payment status
    amount = Column(Float, nullable=True)
    mpesa_receipt_number = Column(String, nullable=True)
    transaction_date = Column(DateTime, nullable=True)
    phone_number = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.now(timezone.utc))



# Database connection
DATABASE_URL = "postgresql://safariconnect:1Amodung%40%21.@192.168.0.102:5432/captive_portal"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, bind=engine)

#Ensuring the tables are created only once
inspector = inspect(engine)
if not inspector.get_table_names():  # Check if tables already exist
    print("Setting up database tables...")
    Base.metadata.create_all(bind=engine)
    print("Tables created.")

try:
    connection = engine.connect()
    print("DataBase Exists and Is connected successfully")
except Exception as e:
    print(f"Database connectio failed: {e}")

# Dependencies
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


// File: Backend/Payment/payment.py
from fastapi import FastAPI, HTTPException, BackgroundTasks, Depends, Request
from fastapi.middleware.cors import CORSMiddleware
from Backend.database.dataBase import get_db, PaymentRecord, Subscription, engine
from pydantic import BaseModel
from sqlalchemy.orm import Session, sessionmaker
from sqlalchemy.exc import SQLAlchemyError
from traceback import format_exc
import requests, logging, asyncio
import base64, time
from datetime import datetime, timedelta
import json, pytz

app = FastAPI()

app.add_middleware(
    CORSMiddleware,  # This is the middleware_class argument
    allow_origins=["*"],  # Add your frontend URL in production
    allow_credentials=True,
    allow_methods= ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allow_headers=["*"]
)

class MPESACredentials:
    CONSUMER_KEY = "O7VPs1yZAADxdI4nszyxI4lAN8IXCX2Glf0gRcNm5SgG5b48"
    CONSUMER_SECRET = "CrKa9Fu9hB65bpNKSF03ZWqCR8QdrHhvGZFjVRSRVM2Jb7ynfx7ctTtJUY0KEhKG"
    PASSKEY = "bfb279f9aa9bdbcf158e97dd71a467cd2e0c893059b10f78e6b72ada1ed2c919"
    BUSINESS_SHORT_CODE = "174379"  # Usually your Paybill number
    CALLBACK_URL = "https://f570-41-209-3-162.ngrok-free.app/payment/mpesa/callback"


class MPESAPayment:
    def __init__(self):
        self.access_token = None
        self.access_token_expiry = None
        
    def generate_password(self):
        """Generate the M-Pesa password using the provided passkey"""
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        data_to_encode = f"{MPESACredentials.BUSINESS_SHORT_CODE}{MPESACredentials.PASSKEY}{timestamp}"
        return base64.b64encode(data_to_encode.encode()).decode('utf-8'), timestamp
        
    async def get_access_token(self):
        """Get the access token required to make M-Pesa API calls"""
        if self.access_token and datetime.now() < self.access_token_expiry:
            return self.access_token
            
        credentials = base64.b64encode(
            f"{MPESACredentials.CONSUMER_KEY}:{MPESACredentials.CONSUMER_SECRET}".encode()
        ).decode('utf-8')
        
        response = requests.get(
            "https://sandbox.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials",
            headers={"Authorization": f"Basic {credentials}"}
        )
        
        if response.status_code != 200:
            raise HTTPException(status_code=400, detail="Failed to get access token")
            
        result = response.json()
        self.access_token = result['access_token']
        # Token expires in 1 hour
        self.access_token_expiry = datetime.now() + timedelta(seconds=3599)
        return self.access_token
        
    async def initiate_stk_push(self, phone_number: str, amount: float, reference: str, db: Session = Depends(get_db)):
        """Initiate STK push to customer's phone"""
        #phone number formating for safaricom API
        if phone_number.startswith("+"):
            phone_number = phone_number[1:]  # Remove leading '+'
        elif phone_number.startswith("0"):
            phone_number = f"254{phone_number[1:]}"  # Convert '0' to '254'
        
        access_token = await self.get_access_token()
        password, timestamp = self.generate_password()
        
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {access_token}",
        }
        
        payload = {
            "BusinessShortCode": MPESACredentials.BUSINESS_SHORT_CODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": int(amount),
            "PartyA": phone_number,
            "PartyB": MPESACredentials.BUSINESS_SHORT_CODE,
            "PhoneNumber": phone_number,
            "CallBackURL": MPESACredentials.CALLBACK_URL,
            "AccountReference": f"Safari Connect. Session_ID: {reference}",
            "TransactionDesc": f"Payment for internet Subscription"
        }
        
        logging.info(f"Payload sent to M-Pesa: {json.dumps(payload, indent=4)}")
        
        try:
            response = requests.post("https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest", headers=headers, json=payload)

            if response.status_code != 200:
                logging.error(f"M-Pesa API Error: {response.status_code} - {response.text}")
                raise HTTPException(status_code=400, detail="Failed to initiate payment")
            
            # Log the successful response
            print(f"M-Pesa Response: {response.json()}")
            
            #store data
            response_data = response.json()
            checkout_id = response_data.get('CheckoutRequestID')
            
            if not checkout_id:
                logging.error("No CheckoutRequestID in M-Pesa response.")
                raise HTTPException(status_code=400, detail="Missing checkout ID in M-Pesa response.")
            
            subscription_id = int(reference)
            
            #STORE IT
            storeed = store_checkout_request(checkout_id, subscription_id, db)
            if storeed:
                print(f"PaymentRecord stored successfully for CheckoutID: {checkout_id}")
            else:
                logging.error(f"Failed To store Checkot Requestfor CheckoutReaquestID: {checkout_id}")
                raise HTTPException(status_code=400, detail="Failed to store Checkout ID in database")
            
            return response_data
        
        except Exception as e:
            logging.error(f"Error initializing M-Pesa payment: {e}")
            raise HTTPException(status_code=500, detail="M-Pesa payment initialization failed")


# FastAPI routes for M-Pesa integration
@app.post("/mpesa/initiate")
async def initiate_payment(
    phone_number: str,
    amount: float,
    subscription_id: int,
    db: Session = Depends(get_db)
):
    print("Hit Gotten on /mpesa/initiate")
    mpesa = MPESAPayment()
    try:
        result = mpesa.initiate_stk_push(
            phone_number=phone_number,
            amount=amount,
            reference=str(subscription_id)
        )
        if result:
            print("\n We've gotten the STK Push\n\n")
    
        checkout_id = result.get('CheckoutRequestID')
        if not checkout_id:
            logging.error("No CheckoutRequestID received from M-Pesa.")
            raise HTTPException(status_code=400, detail="Failed to receive checkout ID from M-Pesa.")
        
        # Attempt to store the PaymentRecord
        storeed = await store_checkout_request(checkout_id, subscription_id, db)
        if storeed:
            print(f"PaymentRecord stored successfully for CheckoutID: {checkout_id}")
        else:
            logging.error(f"Failed To store Checkot Requestfor CheckoutReaquestID: {checkout_id}")
            raise HTTPException(status_code=400, detail="Failed to store Checkout ID in database")
        
        
    except Exception as e:
        logging.error(f"Failed to store PaymentRecord: {e}\n{format_exc()}")
        raise HTTPException(status_code=500, detail="Failed to store payment record.")
    
    return {"message": "Payment initiated", "checkout_id": checkout_id}



@app.post("/mpesa/callback")
async def mpesa_callback(request: Request, db: Session = Depends(get_db)):
    print("M-Pesa callback route hit\n")
    print(f"Received M-Pesa callback request\n.{request}")
    try:
        # Parse JSON payload
        stk_callback_response = await request.json()
        print(f"Parsed JSON payload: {stk_callback_response}")
        result = stk_callback_response.get('Body', {}).get('stkCallback', {})
        # Extract relevant fields from callback
        checkout_id = result.get('CheckoutRequestID')
        result_code = result.get('ResultCode')
        result_desc = result.get('ResultDesc')
        
        print(f"Extracted Callback Details - CheckoutID: {checkout_id}, ResultCode: {result_code}, ResultDesc: {result_desc}")
        # Check if the ResultCode indicates success
        if result_code == 0:
            logging.info("Payment is successful. Extracting metadata...")
            
            # Extract metadata items and ensure all fields are available
            metadata = {item['Name']: item.get('Value') for item in result.get('CallbackMetadata', {}).get('Item', [])}
            amount = metadata.get("Amount")
            receipt_number = metadata.get("MpesaReceiptNumber")
            transaction_date_str = metadata.get("TransactionDate")
            phone_number = metadata.get("PhoneNumber")
            # Log extracted metadata
            print(f"Extracted Metadata - Amount: {amount}, ReceiptNumber: {receipt_number}, TransactionDate: {transaction_date_str}, PhoneNumber: {phone_number}")
            # Validate extracted metadata fields
            if not (amount and receipt_number and transaction_date_str and phone_number):
                logging.error("Incomplete metadata in M-Pesa callback.")
                raise HTTPException(status_code=400, detail="Incomplete callback metadata")
            # Ensure `transaction_date_str` is a string, as `strptime` expects a string
            if isinstance(transaction_date_str, int):
                transaction_date_str = str(transaction_date_str)
                
            # Convert transaction date to datetime object
            try:
                transaction_date = datetime.strptime(transaction_date_str, "%Y%m%d%H%M%S")
            except ValueError as e:
                logging.error(f"Date parsing error: {e}")
                raise HTTPException(status_code=400, detail="Invalid date format in callback")
            
            # Fetch and proceed update PaymentRecord in the database if the CheckoutID was in there ro begin with
            print("Querying PaymentRecord from database.\n")
            retries = 10
            for attempt in range(retries):
                payment_record = db.query(PaymentRecord).filter(PaymentRecord.checkout_id == checkout_id).first()
                if payment_record:
                    break
                await asyncio.sleep(1)
            else:
                logging.warning(f"No PaymentRecord found for CheckoutID: {checkout_id}")
                raise HTTPException(status_code=404, detail="Payment record not found")
            
            print("PaymentRecord found. Updating with transaction details.")
            payment_record.amount = amount
            payment_record.mpesa_receipt_number = receipt_number
            payment_record.transaction_date = transaction_date
            payment_record.phone_number = phone_number
            payment_record.status = "Successful"
            db.commit()
            print("PaymentRecord updated and committed to database.")
            
            # Activate subscription
            print("Activating subscription for successful payment.")
            activated = await retry_callback_activation(checkout_id, db)
            if activated:
                print("Subscription activated successfully.")
                return {"message": "Payment processed successfully"}
        else:
            # Handle failed payment and mark as failed
            logging.info(f"Payment failed with ResultCode: {result_code}. Marking payment as failed.")
            await mark_payment_failed(checkout_id, db)
            logging.info("Payment marked as failed in database.")
            return {"message": f"Payment failed: {result_desc}"}
    except KeyError as e:
        logging.error(f"Missing field in callback data: {e}")
        raise HTTPException(status_code=400, detail="Invalid callback data format")
    except SQLAlchemyError as e:
        logging.error(f"Database error in processing callback: {e}")
        raise HTTPException(status_code=500, detail="Database error during callback processing")
    except Exception as e:
        logging.error(f"Unexpected error in callback processing: {e}")
        raise HTTPException(status_code=500, detail="Error processing callback data")


# handle retries if callback fails.
async def retry_callback_activation(checkout_id: str, db: Session, retries=100, delay=2):
    for attempt in range(retries):
        try:
            result = activate_subscription(checkout_id, db)
            if result:
                print("Subscription activated after callback.")
                return True
        except Exception as e:
            logging.error(f"Retry {attempt+1} failed: {e}")
            time.sleep(delay)
    logging.error(f"Failed to activate subscription after {retries} retries.")


def activate_subscription(checkout_id: str, db: Session):
    """Activate subscription after successful payment"""
    # Retrieve payment record
    payment_record = db.query(PaymentRecord).filter(PaymentRecord.checkout_id == checkout_id).first()
    
    if payment_record:
        # update the subscription status.
        subscription = db.query(Subscription).filter(Subscription.id == payment_record.subscription_id).first()
        if subscription:
            subscription.is_active = True
            db.commit()
            print("Subscription activated")
            return True
        else:
            logging.warning("Subscription Record Pending.. No Found in Database\n")
            raise HTTPException(status_code=400, detail="Subscription status not found on DataBasa\n")


def store_checkout_request(checkout_id: str, subscription_id: int, db: Session):
    """When initiating an M-Pesa transaction, you will receive a CheckoutRequestID that serves as a unique identifier.
    Store this ID and subscription_id in the database to verify payment status later."""
    
    SessionLocal = sessionmaker(autocommit=False, bind=engine)
    db = SessionLocal()
    
    print(f"Storing checkout request - CheckoutID: {checkout_id}, SubscriptionID: {subscription_id}")
    
    try:
        payment_record = PaymentRecord(
            checkout_id=checkout_id,
            subscription_id=subscription_id,
            status="Pending"  # Initial status
        )
        db.add(payment_record)
        db.commit()  # Ensure async commit
        db.refresh(payment_record)
        print("Payment stored successfully")
        
        return True
    except Exception as e:
        print(f"Failed to store checkout request: {e}")
        raise HTTPException(status_code=500, detail="Failed to store payment record.")
    finally:
        db.close()


async def mark_payment_failed(checkout_id: str, db: Session):
    """This function will mark the subscription as inactive or pending in case of payment failure."""
    # Retrieve the payment record
    payment_record = db.query(PaymentRecord).filter(PaymentRecord.checkout_id == checkout_id).first()
    
    if payment_record:
        # Update the subscription status as failed
        subscription = db.query(Subscription).filter(Subscription.id == payment_record.subscription_id).first()
        if subscription:
            subscription.is_active = False
            db.commit()
            print("Payment failed, subscription inactive")




// File: index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Safari Connect</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.2/axios.min.js"></script>
    <link rel="stylesheet" href="style.css">
    <link rel="shortcut icon" href="./resources/safari-icon2.svg" type="image/x-icon">
</head>

<body>
    <div class="container">
        <p style="align-self: center; text-align: center; font-size: medium; font-weight: 300;font-style:italic; font-family: Arial, Helvetica, sans-serif;">
            Explore A Universe Of Possibilities</p>
            <h1>Safari Connect</h1>
        <div class="icon-container">
            <img class="safari-icon" src="resources/safari-icon2.svg" alt="safari connect">
        </div>
        <div class="card">

            <!-- Registration Form -->
            <div id="registerForm">
                <div class="form-group">
                    <label for="phone">Phone Number</label>
                    <input type="tel" id="phone" style="text-align: center;" placeholder="Enter your phone number"
                        required>
                </div>
                <button onclick="register()">Register</button>
            </div>

            <!-- OTP Verification Form -->
            <div id="otpForm" class="hidden">
                <div class="form-group">
                    <label for="otp">Enter OTP</label>
                    <input type="text" id="otp" placeholder="Enter OTP code" required>
                </div>
                <button onclick="verifyOTP()">Verify OTP</button>
            </div>

            <!-- Subscription Plans -->
            <div id="plansForm" class="hidden">
                <h2>Choose a Plan</h2>
                <div class="plans">
                    <div class="plan-card" onclick="selectPlan('1hr')">
                        <h3>1 Hour</h3>
                        <p>KSh 10</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('2hrs')">
                        <h3>2 Hours</h3>
                        <p>KSh 20</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('3hrs')">
                        <h3>3 Hours</h3>
                        <p>KSh 30</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('8hrs')">
                        <h3>8 Hours</h3>
                        <p>KSh 80</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('12hrs')">
                        <h3>12 Hours</h3>
                        <p>KSh 100</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('24hrs')">
                        <h3>24 Hours</h3>
                        <p>KSh 150</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('3 days')">
                        <h3> 3 Days</h3>
                        <p>KSh 300</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('1 week')">
                        <h3>1 Week</h3>
                        <p>KSh 550</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('2 weeks')">
                        <h3>2 Weeks</h3>
                        <p>KSh 1000</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('monthly')">
                        <h3>Monthly</h3>
                        <p>KSh 1750</p>
                    </div>
                </div>
                <button onclick="subscribe()" class="hidden" id="subscribeBtn">Subscribe</button>
            </div>
        </div>
        <div class="card3">
            <!-- Subscription Plans -->
            <div id="plansForm3" class="hidden">
                <h2>Choose a Plan</h2>
                <div class="plans">
                    <div class="plan-card" onclick="selectPlan('1hr')">
                        <h3>1 Hour</h3>
                        <p>KSh 10</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('2hrs')">
                        <h3>2 Hours</h3>
                        <p>KSh 20</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('3hrs')">
                        <h3>3 Hours</h3>
                        <p>KSh 30</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('8hrs')">
                        <h3>8 Hours</h3>
                        <p>KSh 80</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('12hrs')">
                        <h3>12 Hours</h3>
                        <p>KSh 100</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('24hrs')">
                        <h3>24 Hours</h3>
                        <p>KSh 150</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('3 days')">
                        <h3> 3 Days</h3>
                        <p>KSh 300</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('1 week')">
                        <h3>1 Week</h3>
                        <p>KSh 550</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('2 weeks')">
                        <h3>2 Weeks</h3>
                        <p>KSh 1000</p>
                    </div>
                    <div class="plan-card" onclick="selectPlan('monthly')">
                        <h3>Monthly</h3>
                        <p>KSh 1750</p>
                    </div>
                </div>
                <button onclick="subscribe()" class="hidden" id="subscribeBtn3">Subscribe</button>
            </div>
        </div>
    </div>
    <script src="index.js"></script>
</body>

</html>


// File: index.js
const API_BASE_URL = 'http://192.168.0.102:8000';
let selectedPlan = null;
let currentUser = null;
let paymentStatusInterval = null;

document.addEventListener('DOMContentLoaded', () => {
    const card3 = document.getElementById('card3');
    if (card3)
    {
        card3.classList.add('hidden');
    }
    const storedToken = getToken();
    if (storedToken) {
        const decodedToken = parseJwt(storedToken);

        if (!isTokenExpired(decodedToken)) {
            currentUser = decodedToken;
            console.log('User is still Authenticared:', currentUser);
            document.getElementById('registerForm').classList.add('hidden');
            document.getElementById('otpForm').classList.add('hidden');

            if (currentUser.subscription_active) {
                showSessionCountdown(currentUser.time_left);
            } else {
                document.getElementById('plansForm').classList.remove('hidden');
            }
        } else {
            handleExpiredTokens();
        }
    } else {
        document.getElementById('registerForm').classList.remove('hidden');
        document.getElementById('otpForm').classList.add('hidden');
        document.getElementById('plansForm').classList.add('hidden');
    }
});


async function getMacAddress() {
    try {
        const response = await axios.get(`${API_BASE_URL}/mac-address`, {headers: getAuthHeaders()});
        return response.data.mac_address || "MAC not found";
    } catch (error) {
        console.error("Failed to retrieve MAC address:", error);
        return "Error retrieving MAC";
    }
}

async function register() {
    const phone = document.getElementById('phone').value;
    const macAddress = await getMacAddress();
    console.log({
        phone_number: phone,
        mac_address: macAddress
    });
    try {
        const response = await axios.post(`${API_BASE_URL}/register`, {
            phone_number: phone,
            mac_address: macAddress
        }, {headers: getAuthHeaders()});
        //console.log("Registration response:", response);
        document.getElementById('registerForm').classList.add('hidden');
        document.getElementById('otpForm').classList.remove('hidden');
    } catch (error) {
        console.error("Registration failed:", error);
        showError('Registration failed. Please try again.');
    }
}

async function verifyOTP() {
    const otp = document.getElementById('otp').value;
    const phone = document.getElementById('phone').value;
    try {
        const response = await axios.post(`${API_BASE_URL}/verify-otp`, {
            phone_number: phone,
            otp_code: otp,
        }, {headers: getAuthHeaders()});

        const token = response.data.token;
        localStorage.setItem('token', token);
        const decodedToken = parseJwt(token);
        console.log("This here is the decoded Token parsed with jwt");
        console.log(decodedToken);
        currentUser = decodedToken;

        if (isTokenExpired(currentUser)) {
            localStorage.removeItem('token');
            document.getElementById('otpForm').classList.remove('hidden');
        }

        if (decodedToken.subscription_active) {
            // User has an active subscription
            console.log("calling showSessionCountdwn()");
            showSessionCountdown(decodedToken.time_left);
        } else {
            console.log("no active subscription");
            document.getElementById('otpForm').classList.add('hidden');
            document.getElementById('plansForm').classList.remove('hidden');
        }

    } catch (error) {
        showError('Invalid OTP. Please try again.');
    }
}


async function subscribe() {
    // Ensuring selected plan and current user details are available
    if (!selectedPlan) {
        showError("Please select a subscription plan.");
        return;
    }
    
    if (!currentUser || !currentUser.user_id) {
        showError("User information is missing. Please try re-verifying your OTP.");
        return;
    }

    try {
        // request data
        const requestData = {
            user_id: currentUser.user_id,  // Ensure user_id is correct
            plan_type: selectedPlan        // Ensure plan_type is set to selected plan
        };
        console.log("Subscription request data:", requestData); // For debugging

        // Send request to backend
        const response = await axios.post(`${API_BASE_URL}/subscribe`, requestData, {headers: getAuthHeaders()});

        const additionalTime = response.data.time_in_seconds || 0;
        let timeLeft = 0;

        timeLeft += additionalTime;

        startPaymentStatusPolling();
        
        // Handle response after successful subscription initiation
        if (response.data && response.data.message) {
            showSuccess(response.data.message);
        } else {
            showSuccess("Subscription initiated. Please complete payment on your phone.");
        }
    } catch (error) {
        console.error("Subscription error:", error.response ? error.response.data : error.message);
        showError("Subscription failed. Please try again.");
    }
}

async function checkPaymentStatus() {
    try {
        const response = await axios.get(`${API_BASE_URL}/subscription-status`, {
            params: { user_id: currentUser.user_id },
        }, {headers: getAuthHeaders()});

        console.log("Subscription status response:", response.data);

        if (response.data.subscription_active) {
            showSuccess("Payment successful. Subscription activated!");
            clearInterval(paymentStatusInterval);
            console.log("update the UI Now")
            // Start countdown with time_left from the server
            showSessionCountdown(response.data.time_left);
        } else {
            console.log("Payment still processing...");
        }
    } catch (error) {
        console.error("Error checking payment status:", error);
    }
}

// functions //

function selectPlan(plan) {
    selectedPlan = plan;
    document.querySelectorAll('.plan-card').forEach(card => {
        card.classList.remove('selected');
    });
    event.currentTarget.classList.add('selected');
    document.getElementById('subscribeBtn').classList.remove('hidden');
}

function showError(message) {
    const error = document.createElement('div');
    error.className = 'error';
    error.textContent = message;
    document.querySelector('.card').appendChild(error);
    setTimeout(() => error.remove(), 3000);
}

function showSuccess(message) {
    const success = document.createElement('div');
    success.className = 'success';
    success.textContent = message;
    document.querySelector('.card').appendChild(success);
    setTimeout(() => success.remove(), 3000);
}

function parseJwt(token) {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(atob(base64).split('').map(function (c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));
    
    return JSON.parse(jsonPayload);
}

function showSessionCountdown(timeLeft) {
    console.log("now showing session countdown");
    const countdownContainer = document.createElement('div');
    countdownContainer.className = 'countdown-container';

    document.querySelector('.card').innerHTML = '';
    document.querySelector('.card').appendChild(countdownContainer);

    countdownContainer.innerHTML = `
        <div class="countdown-container-message">
            <h3>Tik Tok <br> Goes The Clock</h3>
            <p style="align-self: center; text-align: center; font-size: medium; font-weight: 300; font-style: italic; font-family: Arial, Helvetica, sans-serif;">
                Enjoy The Internet <br> :-)
                </p>
        </div>
        `;
    const timerText = document.createElement('p');
    timerText.className = 'timer-text';
    countdownContainer.appendChild(timerText);
    
    const buyMore = document.createElement('button');
    buyMore.className = 'buy-more-button';
    buyMore.textContent = "Buy More Time";
    countdownContainer.appendChild(buyMore);

    buyMore.addEventListener('click', () => {
        document.getElementById('plansForm3').classList.remove('hidden');
        document.getElementById('subscribeBtn3').classList.remove('hidden');
        document.getElementById('card3').classList.remove('hidden');
    });

    function updateCountdown() {
        if (timeLeft <= 0) {
            clearInterval(countdownInterval);
            countdownContainer.textContent = 'Session expired. Please select a plan.';
            document.getElementById('plansForm').classList.remove('hidden');
            checkPaymentStatus();
            return;
        }
        
        const hours = Math.floor(timeLeft / 3600);
        const minutes = Math.floor((timeLeft % 3600) / 60);
        const seconds = Math.floor(timeLeft % 60);
        
        timerText.textContent = `Session time left \n ${hours}h ${minutes}m ${seconds}s`;
        timeLeft--;
    }
    
    const countdownInterval = setInterval(updateCountdown, 1000);
    updateCountdown();
}

// Start polling every 5 seconds after initiating payment
function startPaymentStatusPolling() {
    if (paymentStatusInterval) clearInterval(paymentStatusInterval);
    paymentStatusInterval = setInterval(checkPaymentStatus, 5000);
}

// check if Access token is expired
function isTokenExpired(mytoken) {
    const now = Math.floor(Date.now() / 1000);
    return mytoken.exp < now;
}

function getToken() {
    return localStorage.getItem('token');
}

function getAuthHeaders() {
    const token = getToken();
    if (token) {
        return {
            'Authorization': `Bearer ${token}`
        };
    }
    return {};
}

function handleExpiredTokens() {
    localStorage.removeItem('token');
    cirrentUser = null;
    document.getElementById('otpForm').classList.remove('hidden');
}


// File: OpenTWRP/dhcp
# /etc/config/dhcp
config dnsmasq
    option domainneeded '1'
    option boguspriv '1'
    option filterwin2k '0'
    option localise_queries '1'
    option rebind_protection '1'
    option rebind_localhost '1'
    option local '/lan/'
    option domain 'lan'
    option expandhosts '1'
    option nonegcache '0'
    option authoritative '1'
    option readethers '1'
    option leasefile '/tmp/dhcp.leases'
    option resolvfile '/tmp/resolv.conf.auto'

config dhcp 'lan'
    option interface 'lan'
    option start '100'
    option limit '150'
    option leasetime '12h'


// File: OpenTWRP/firewll
# Firewall rules (/etc/config/firewall)
# Allow access to captive portal
config rule
    option name 'Allow-Captive-Portal'
    option src 'lan'
    option dest_port '80'
    option proto 'tcp'
    option target 'ACCEPT'

# Block all other traffic for unauthenticated users
config rule
    option name 'Block-Unauthenticated'
    option src 'lan'
    option proto 'all'
    option target 'DROP'


// File: OpenTWRP/network
# /etc/config/network
config interface 'loopback' # type: ignore
    option device 'lo' # type: ignore
    option proto 'static' # type: ignore
    option ipaddr '127.0.0.1' # type: ignore
    option netmask '255.0.0.0' # type: ignore

config interface 'lan' # type: ignore
    option device 'eth0' # type: ignore
    option proto 'static' # type: ignore
    option ipaddr '192.168.1.1' # type: ignore
    option netmask '255.255.255.0' # type: ignore


// File: OpenTWRP/nodogsplash
# /etc/config/nodogsplash
config nodogsplash
    option enabled '1'
    option gatewayname 'WiFi Hotspot'
    option gatewayinterface 'br-lan'
    option maxclients '250'
    option clientidletimeout '1440'
    option webroot '/etc/nodogsplash/htdocs'
    option redirecturl 'http://your-portal-url'
    
# Authentication script
option authenticateimmediately '0'
option passwordattempts '5'
option gatewayiprange '192.168.1.0/24'


// File: style.css
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
}

body {
    background: #f0f2f5;
    color: #1a1a1a;
    line-height: 1.6;
}

.container {
    max-width: 400px;
    margin: 2rem auto;
    padding: 1rem;
}

.contdown-container {
    max-width: 400px;
    margin: 2rem auto;
    padding: 1rem;
}
.card, .card3 {
    background: white;
    border-radius: 8px;
    padding: 2rem;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    text-align: center;
}

.card3 {
    margin-top: 10px;
}
h1, h3 {
    text-align: center;
    color: #1a73e8;
    margin-bottom: 1.5rem;
}

.form-group {
    margin-bottom: 1rem;
}

label {
    display: block;
    margin-bottom: 0.5rem;
    color: #666;
}

input {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 1rem;
}

button {
    width: 100%;
    padding: 0.75rem;
    background: #1a73e8;
    color: white;
    border: none;
    border-radius: 4px;
    font-size: 1rem;
    cursor: pointer;
    transition: background 0.3s;
}

button:hover {
    background: #1557b0;
}

.plans {
    display: grid;
    gap: 1rem;
    margin-top: 1rem;
}

.plan-card {
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 1rem;
    cursor: pointer;
    transition: all 0.3s;
}

.plan-card:hover {
    border-color: #1a73e8;
    transform: translateY(-2px);
}

.plan-card.selected {
    border-color: #1a73e8;
    background: #f8f9fe;
}

.error {
    color: #d93025;
    margin-top: 0.5rem;
    font-size: 0.875rem;
}

.success {
    color: #188038;
    margin-top: 0.5rem;
    font-size: 0.875rem;
}

.hidden {
    display:none;
}

.icon-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: fit-content;
}

.safari-icon {
    height: 200px;
}


