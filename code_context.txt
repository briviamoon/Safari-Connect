// File: app/auth/deps.py
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import jwt, JWTError
from sqlalchemy.orm import Session
from app.config.database import get_db
from app.models.user import User
from app.auth.security import SECRET_KEY, ALGORITHM

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    """
    Decodes JWT token and retrieves the current user from the database.
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if not username:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid authentication credentials",
                headers={"WWW-Authenticate": "Bearer"},
            )

        user = db.query(User).filter_by(username=username).first()
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found",
                headers={"WWW-Authenticate": "Bearer"},
            )

        return user

    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has expired",
            headers={"WWW-Authenticate": "Bearer"},
        )

    except JWTError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"JWT decoding failed: {str(e)}",
            headers={"WWW-Authenticate": "Bearer"},
        )



// File: app/auth/security.py
from datetime import datetime, timedelta
import logging
from app.config.settings import settings
from app.utils.timezone import current_utc_time
from fastapi import HTTPException, status
from jose import JWTError, jwt

SECRET_KEY = settings.SECRET_KEY
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 1440  # Token expiration time in minutes

def create_access_token(data: dict) -> str:
    """
    Create a JWT access token with an expiration time.
    """
    try:
        logging.info("encoding User Data ...")
        to_encode = data.copy()
        logging.info("setting Expiry time ...")
        expire = current_utc_time() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        logging.info(f"Expiry set to: {expire}")
        logging.info("Updating data with expiration time")
        to_encode.update({"exp": expire})
        logging.info("updated data with expiration time ...")
        logging.info("encoding User Data to Session Token ...")
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        logging.info(f"Encoded token is now: {encoded_jwt}")
        return encoded_jwt
    except Exception as e:
        logging.error(f"Error creating token: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating token: {str(e)}",
        )


def verify_token(token: str):
    """
    Verify a JWT token and return the decoded payload.
    """
    try:
        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has expired",
        )
    except JWTError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"JWT decoding failed: {str(e)}",
        )



// File: app/config/database.py
from sqlalchemy import create_engine, inspect
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import logging

from app.config.settings import settings

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

DATABASE_URL = settings.DATABASE_URL

# Database engine and session
engine = create_engine(DATABASE_URL, pool_pre_ping=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def init_database():
    """
    Initialize the database by creating tables if they don't exist.
    """
    try:
        inspector = inspect(engine)
        existing_tables = inspector.get_table_names()
        if not existing_tables:
            logger.info("Creating database tables...")
            Base.metadata.create_all(bind=engine)
            logger.info("Database initialized successfully.")
        else:
            logger.info(f"Tables already exist: {existing_tables}. Skipping creation.")
    except Exception as e:
        logger.error(f"Error initializing the database: {e}")
        raise

# Database dependency
def get_db():
    """
    Provide a transactional scope around a series of operations.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()



// File: app/config/settings.py
from pydantic_settings import BaseSettings
from pydantic import Field, ValidationError


# noinspection PyArgumentList
class Settings(BaseSettings):
    """
    Application settings loaded from environment variables.
    Provides default values and validation for critical settings.
    """
    SECRET_KEY: str = Field(..., env="SECRET_KEY")
    DATABASE_URL: str = Field(..., env="DATABASE_URL")
    M_PESA_CONSUMER_KEY: str = Field(..., env="M_PESA_CONSUMER_KEY")
    M_PESA_CONSUMER_SECRET: str = Field(..., env="M_PESA_CONSUMER_SECRET")
    M_PESA_PASSKEY: str = Field(..., env="M_PESA_PASSKEY")
    M_PESA_SHORTCODE: str = Field(..., env="M_PESA_SHORTCODE")
    CALLBACK_URL: str = Field(..., env="CALLBACK_URL")
    NGROK_URL: str = Field(..., env="NGROK_URL")
    IPV4_CURRENT: str = Field(..., env="IPV4_CURRENT")
    AFRICAS_TALKING_API_KEY: str = Field(..., env="AFRICAS_TALKING_API_KEY")
    AFRICAS_TALKING_USERNAME: str = Field(..., env="AFRICAS_TALKING_USERNAME")

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

try:
    settings = Settings()
except ValidationError as e:
    print("Configuration Error: Ensure all required environment variables are set.")
    print(e.json())
    raise



// File: app/main.py
from pathlib import Path

from fastapi import FastAPI, Depends, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

from app.auth.deps import get_current_user
from app.config.database import init_database
from app.config.settings import settings
from app.middleware.ip_whitelist import allow_ip_middleware
from app.routes import user, subscription, payment, mac_address

app = FastAPI()

# Configure templates and static files
app.mount("/static", StaticFiles(directory=Path(__file__).parent / "static"), name="static")
templates = Jinja2Templates(directory=Path(__file__).parent / "templates")

NGROK_URL = settings.NGROK_URL
ALLOWED_METHODS = ["*"]
ALLOWED_HEADERS = ["*"]
# Configure CORS settings
app.add_middleware(
    CORSMiddleware,
    allow_origins=[f"{NGROK_URL}"],
    allow_credentials=True,
    allow_methods= ALLOWED_METHODS,
    allow_headers= ALLOWED_HEADERS,
)

# Middlewares
app.middleware("http")(allow_ip_middleware)

# Routes
app.include_router(user.router, prefix="/user", tags=["User"])
app.include_router(subscription.router, prefix="/subscription", tags=["Subscription"])
app.include_router(payment.router, prefix="/payment", tags=["Payment"])
app.include_router(mac_address.router, prefix="/mac_address", tags=["MAC Address"])

# Init Db
init_database()


@app.options("/mac_address/{mac_address}")
async def handle_options():
    return {"message": "CORS preflight request handled"}


# root of app
@app.get("/")
async def home(request: Request):
    ngrok_url = settings.NGROK_URL
    ipv4_url = settings.IPV4_CURRENT
    print(f"Serving NgrokURL as API BASE: {ngrok_url}\n")
    return templates.TemplateResponse("index.html", {"request": request, "skibidi": ngrok_url, "rizz": ipv4_url})

# Check on the Session Token
# dependency function when I need a user session validated

@app.get("/protected-endpoint")
async def protected_route(user:dict = Depends(get_current_user)):
    return {"message": "Access granted", "user": user}




// File: app/middleware/ip_whitelist.py
from fastapi import Request, HTTPException

# whitelisted IP addresses
ALLOWED_CALLBACK_IPS = [
    "196.201.214.200", "196.201.214.206", "196.201.213.114",
    "196.201.214.207", "196.201.214.208", "196.201.213.44",
    "196.201.212.127", "196.201.212.138", "196.201.212.129",
    "196.201.212.136", "196.201.212.74", "196.201.212.69",
    "192.168.0.102"
]

# allow ip to give callback to the API's
async def allow_ip_middleware(request: Request, call_next):
    if request.url.path == "/payment/mpesa/callback" and request.client.host not in ALLOWED_CALLBACK_IPS:
        # raise HTTPException(status_code=403, detail="Access denied: IP not Allowed")
        return await call_next(request)
    return await call_next(request)




// File: app/models/otp.py
from sqlalchemy import Column, Integer, String, Float, DateTime, Boolean
from app.config.database import Base
from datetime import datetime, timezone
from app.utils.timezone import current_utc_time


class OTP(Base):
    __tablename__ = "otps"
    id = Column(Integer, primary_key=True, index=True)
    phone_number = Column(String)
    otp_code = Column(String)
    created_at = Column(DateTime, default=current_utc_time)
    is_used = Column(Boolean, default=False)


// File: app/models/payment_record.py
from sqlalchemy import Column, Integer, String, DateTime, Float
from app.config.database import Base
from app.utils.timezone import current_utc_time


# base mode for Payment record in db
class PaymentRecord(Base):
    __tablename__ = "payment_records"
    id = Column(Integer, primary_key=True, index=True)
    checkout_id = Column(String, unique=True, index=True)  # The M-Pesa transaction ID
    subscription_id = Column(Integer)  # Links to the Subscription table
    status = Column(String, default="Pending")  # Payment status
    amount = Column(Float, nullable=True)
    mpesa_receipt_number = Column(String, nullable=True)
    transaction_date = Column(DateTime, nullable=True)
    phone_number = Column(String, nullable=True)
    created_at = Column(DateTime, default=current_utc_time)




// File: app/models/subscription.py
from sqlalchemy import Column, Integer, String, Float, DateTime, Boolean
from app.config.database import Base

# base model for Subscription in db

class Subscription(Base):
    __tablename__ = "subscriptions"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer)
    plan_type = Column(String)
    amount = Column(Float)
    start_time = Column(DateTime)
    end_time = Column(DateTime)
    is_active = Column(Boolean, default=False)




// File: app/models/user.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean
from datetime import datetime
from app.config.database import Base

# base model for A user in db
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    phone_number = Column(String, unique=True, index=True)
    mac_address = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)
    is_active = Column(Boolean, default=False)




// File: app/routes/mac_address.py
from fastapi import APIRouter, Request, Depends, HTTPException
import subprocess, platform, uuid, socket, logging, asyncio
from app.auth.deps import get_current_user

router = APIRouter()
#Get Client MAC ADDRESS

@router.get("/mac-address")
async def get_mac_address(req: Request, user=Depends(get_current_user)):
    if not isinstance(req, Request):
        logging.error("Received a non-Request object.")
        return {
            "status": "error",
            "message": "Invalid request object"
        }

    try:
        print(f"Request type: {type(req)}")
        client_ip = req.client.host
        logging.info(f"Attempting to retrieve MAC for IP: {client_ip}")
        
        # if async is still waiting ...
        if asyncio.iscoroutinefunction(get_mac_from_ip):
            mac_address = await get_mac_from_ip(client_ip)
        else:
            mac_address = get_mac_from_ip(client_ip)
        
        # Check if MAC address was successfully retrieved; otherwise use fallback
        if not mac_address:
            mac_address = "00:00:00:00:00:00"  # Placeholder for unobtainable MAC
        
        return {
            "status": "success" if mac_address else "error",
            "mac_address": mac_address,
            "client_ip": client_ip
        }
    except Exception as e:
        logging.error(f"Error in MAC address endpoint: {e}")
        return {
            "status": "error",
            "message": "An unexpected error occurred",
            "client_ip": client_ip if 'client_ip' in locals() else "unknown"
        }


#############################################################################
def get_mac_from_ip(ip_address):
    """
    Attempt to retrieve MAC address for a given IP address using multiple methods.
    
    Args:
        ip_address (str): IP address to find MAC for
    
    Returns:
        str: MAC address if found, None otherwise
    """
    try:
        # Method 1: Use system-specific ARP commands
        os_system = platform.system().lower()
        
        if os_system == 'windows':
            try:
                # Windows ARP command
                result = subprocess.run(['arp', '-a', ip_address], 
                                        capture_output=True, 
                                        text=True, 
                                        timeout=5)
                # Parse ARP output to extract MAC
                for line in result.stdout.split('\n'):
                    if ip_address in line:
                        # Extract MAC address (typically in format xx-xx-xx-xx-xx-xx)
                        mac = line.split()[-1].replace('-', ':')
                        if mac and len(mac.split(':')) == 6:
                            return mac
            except Exception as e:
                logging.error(f"Windows ARP lookup failed: {e}")
        
        elif os_system in ['linux', 'darwin']:  # Linux or macOS
            try:
                # Linux/macOS ARP command
                result = subprocess.run(['arp', '-n', ip_address], 
                                        capture_output=True, 
                                        text=True, 
                                        timeout=5)
                # Parse ARP output to extract MAC
                for line in result.stdout.split('\n'):
                    if ip_address in line:
                        # Extract MAC address (typically in format xx:xx:xx:xx:xx:xx)
                        parts = line.split()
                        mac = parts[2] if len(parts) > 2 else None
                        if mac and len(mac.split(':')) == 6:
                            return mac
            except Exception as e:
                logging.error(f"Linux/macOS ARP lookup failed: {e}")
        
        # Method 2: Fallback to UUID (if above methods fail)
        # This will return a pseudo-MAC based on the system's UUID
        if ip_address == '127.0.0.1' or ip_address == '::1':
            logging.warning("Returning local UUID-based MAC, which may not be reliable for client identification.")
            return str(uuid.getnode())
        
        # Additional fallback: Try socket method
        try:
            hostname = socket.gethostbyaddr(ip_address)[0]
            # Attempt to get MAC via hostname (not reliable for remote IPs)
            mac = ':'.join(['{:02x}'.format((uuid.getnode() >> elements) & 0xff) 
                            for elements in range(0,2*6,2)][::-1])
            return mac
        except Exception as e:
            logging.error(f"Hostname MAC lookup failed: {e}")
        
        return None
    
    except Exception as e:
        logging.error(f"Unexpected error in get_mac_from_ip: {e}")
        return None


// File: app/routes/payment.py
from fastapi import APIRouter, Request, Depends, HTTPException
from app.models.payment_record import PaymentRecord
from app.models.subscription import Subscription
from app.config.database import get_db
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
from datetime import datetime, time
import logging, traceback, asyncio

router = APIRouter()


##########################################

##########################################
@router.post("/mpesa/callback")
async def mpesa_callback(request: Request, db: Session = Depends(get_db)):
    logging.info("M-Pesa callback route hit")
    logging.info(f"Received M-Pesa callback request\n.{request}")
    try:
        # Parse JSON payload
        stk_callback_response = await request.json()
        print(f"Parsed JSON payload: {stk_callback_response}")
        result = stk_callback_response.get('Body', {}).get('stkCallback', {})
        # Extract relevant fields from callback
        checkout_id = result.get('CheckoutRequestID')
        result_code = result.get('ResultCode')
        result_desc = result.get('ResultDesc')

        logging.info(f"Extracted Callback Details - CheckoutID: {checkout_id}, ResultCode: {result_code}, ResultDesc: {result_desc}")
        # Check if the ResultCode indicates success
        if result_code == 0:
            logging.info("Payment is successful. Extracting metadata...")

            # Extract metadata items and ensure all fields are available
            metadata = {item['Name']: item.get('Value') for item in result.get('CallbackMetadata', {}).get('Item', [])}
            amount = metadata.get("Amount")
            receipt_number = metadata.get("MpesaReceiptNumber")
            transaction_date_str = metadata.get("TransactionDate")
            phone_number = metadata.get("PhoneNumber")
            # Log extracted metadata
            logging.info(f"Extracted Metadata - Amount: {amount}, ReceiptNumber: {receipt_number}, TransactionDate: {transaction_date_str}, PhoneNumber: {phone_number}")
            # Validate extracted metadata fields
            if not (amount and receipt_number and transaction_date_str and phone_number):
                logging.error("Incomplete metadata in M-Pesa callback.")
                raise HTTPException(status_code=400, detail="Incomplete callback metadata")
            # Ensure `transaction_date_str` is a string, as `strptime` expects a string
            if isinstance(transaction_date_str, int):
                transaction_date_str = str(transaction_date_str)

            # Convert transaction date to datetime object
            try:
                transaction_date = datetime.strptime(transaction_date_str, "%Y%m%d%H%M%S")
            except ValueError as e:
                logging.error(f"Date parsing error: {e}")
                raise HTTPException(status_code=400, detail="Invalid date format in callback")

            # Fetch and proceed update PaymentRecord in the database if the CheckoutID was in there ro begin with
            print("Querying PaymentRecord from database.\n")
            retries = 10
            for attempt in range(retries):
                payment_record = db.query(PaymentRecord).filter(PaymentRecord.checkout_id == checkout_id).first()
                if payment_record:
                    break
                await asyncio.sleep(1)
            else:
                logging.warning(f"No PaymentRecord found for CheckoutID: {checkout_id}")
                raise HTTPException(status_code=404, detail="Payment record not found")
            
            
            print("PaymentRecord found. Updating with transaction details.")
            payment_record.amount = amount
            payment_record.mpesa_receipt_number = receipt_number
            payment_record.transaction_date = transaction_date
            payment_record.phone_number = phone_number
            payment_record.status = "Successful"
            db.commit()
            logging.info("PaymentRecord updated and committed to database.")

            # Activate subscription
            logging.info("Activating subscription for successful payment.")
            activated = await retry_callback_activation(checkout_id, db=db)
            if activated:
                logging.info("Subscription activated successfully.")
                return {"message": "Payment processed successfully"}
            else:
                logging.error("Failed to activate subscription after payment.")
                raise HTTPException(status_code=500, detail="Failed to activate subscription")
        else:
            # Handle failed payment and mark as failed
            logging.info(f"Payment failed with ResultCode: {result_code}. Marking payment as failed.")
            await mark_payment_failed(checkout_id, db)
            return {"message": f"Payment failed: {result_desc}"}
    except KeyError as e:
        logging.error(f"Missing field in callback data: {e}")
        raise HTTPException(status_code=400, detail="Invalid callback data format")
    except SQLAlchemyError as e:
        logging.error(f"Database error in processing callback: {e}")
        raise HTTPException(status_code=500, detail="Database error during callback processing")
    except Exception as e:
        logging.error(f"Unexpected error in callback processing: {e}")
        raise HTTPException(status_code=500, detail="Error processing callback data")


######################################
# handle retries if callback fails.
async def retry_callback_activation(checkout_id: str, db: Session, retries=10, delay=2):
    for attempt in range(1, retries+ 1):
        try:
            result = activate_subscription(checkout_id, db=db)
            if result:
                logging.info(f"Subscription activated on attempt {attempt}.")
                return True
        except Exception as e:
            logging.error(f"Retry {attempt+1} failed: {e}")
            await asyncio.sleep(delay * attempt)
            
    logging.error(f"Failed to activate subscription after {retries} retries.")
    return False


def activate_subscription(checkout_id: str, db: Session):
    """Activate subscription after successful payment"""
    # Retrieve payment record
    payment_record = db.query(PaymentRecord).filter(PaymentRecord.checkout_id == checkout_id).first()
    
    if payment_record:
        # update the subscription status.
        subscription = db.query(Subscription).filter(Subscription.id == payment_record.subscription_id).first()
        if subscription:
            subscription.is_active = True
            db.commit()
            print("Subscription activated")
            return True
        else:
            logging.warning("Subscription Record Pending.. No Found in Database\n")
            raise HTTPException(status_code=400, detail="Subscription status not found on DataBasa\n")


async def mark_payment_failed(checkout_id: str, db: Session):
    """This function will mark the subscription as inactive or pending in case of payment failure."""
    # Retrieve the payment record
    payment_record = db.query(PaymentRecord).filter(PaymentRecord.checkout_id == checkout_id).first()
    
    if payment_record:
        # Update the subscription status as failed
        subscription = db.query(Subscription).filter(Subscription.id == payment_record.subscription_id).first()
        if subscription:
            subscription.is_active = False
            db.commit()
            print("Payment failed, subscription inactive")


// File: app/routes/subscription.py
from fastapi import APIRouter, Depends, Request, HTTPException
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
from app.models.subscription import Subscription
from app.models.user import User
from app.config.database import get_db
from app.services.mpesa_services import initiate_stk_push
from app.utils.timezone import current_utc_time, utc_to_eat
from app.schemas.subscription import SubscriptionCreate
from fastapi.templating import Jinja2Templates
from pathlib import Path
from fastapi.responses import HTMLResponse
from datetime import datetime, timedelta, timezone
import logging

router = APIRouter()

@router.post("/subscribe")
async def create_subscription(request: SubscriptionCreate, db: Session = Depends(get_db)):
    print(f"Received request: {request}")
    print(f"User ID from request: {request.user_id}")
    # Plan configurations
    plans = {
        "1hr": {"amount": 1, "duration": timedelta(hours=1)},
        "2hrs": {"amount": 25, "duration": timedelta(hours=2)},
        "3hrs": {"amount": 35, "duration": timedelta(hours=3)},
        "8hrs": {"amount": 80, "duration": timedelta(hours=8)},
        "12hrs": {"amount": 100, "duration": timedelta(hours=12)},
        "24hrs": {"amount": 150, "duration": timedelta(days=1)},
        "3 days": {"amount": 300, "duration": timedelta(days=3)},
        "1 week": {"amount": 550, "duration": timedelta(weeks=1)},
        "2 weeks": {"amount": 1000, "duration": timedelta(weeks=2)},
        "monthly": {"amount": 1750, "duration": timedelta(days=30)}
    }
    
    if request.plan_type not in plans:
        raise HTTPException(status_code=400, detail="Invalid plan type")
    
    plan = plans[request.plan_type]
    
    try:
        with db.begin():
            subscription = Subscription(
                user_id=request.user_id,
                plan_type=request.plan_type,
                amount=plan["amount"],
                start_time=current_utc_time(),
                end_time=current_utc_time() + plan["duration"],
                is_active=False
            )
        logging.info(f"Created subscription object: {subscription}")
        db.add(subscription)
        db.commit()
    
        # Initiate M-Pesa payment
        response = await initiate_mpesa_payment(subscription.id, plan["amount"], db=db)
        return {"message": "Subscription initiated, payment pending", "mpesa_response": response}
    
    except SQLAlchemyError as e:
        logging.error(f"Database error during subscription creation: {e}")
        raise HTTPException(status_code=500, detail="Database error occurred")
    except Exception as e:
        logging.error(f"Unexpected error during Subscription creation: {e}")
        raise HTTPException(status_code=500, detail="Unexpected server error")


#creating a subscription status checker
@router.get("/subscription-status")
async def subscription_status(user_id: int, db: Session = Depends(get_db)):
    print(f"Checking subscription status for user: {user_id}")
    
    # Query the subscription record for the given user_id
    subscription = db.query(Subscription).filter(Subscription.user_id == user_id).first()
    
    if not subscription:
        logging.info(f"No subscription found for user {user_id}")
        return {"subscription_active": False, "time_left": 0}

    logging.info(f"Subscription for user {subscription.user_id} is {'active' if subscription.is_active else 'inactive'}")
    
    # If the subscription is active, calculate the time left
    if subscription.is_active:
        if subscription.end_time:
            # Ensure `end_time` is timezone-aware
            if subscription.end_time.tzinfo is None:
                subscription.end_time = subscription.end_time.replace(tzinfo=timezone.utc)
            
            # Calculate time left in seconds
            time_left = (subscription.end_time - current_utc_time()).total_seconds()
            logging.info(f"Time left for user {user_id}: {time_left} seconds")
            return {"subscription_active": True, "time_left": max(time_left, 0)}

        # Handle case where `end_time` is None or invalid
        logging.warning(f"Subscription for user {user_id} has no valid end_time")
        return {"subscription_active": True, "time_left": 0}
    
    # If subscription is inactive
    return {"subscription_active": False, "time_left": 0}


def initiate_mpesa_payment(subscription_id: int, amount: float, db: Session):
    # Retrieve the user's phone number from the database
    subscription = db.query(Subscription).filter(Subscription.id == subscription_id).first()
    user = db.query(User).filter(User.id == subscription.user_id).first()
    
    if not user:
        raise HTTPException(status_code=404, detail="user not found")
    
    phone_number = user.phone_number
    
    try:
        # STK PUSH INITIATE
        print("Initiating Mpesa STK Push Now")
        response = initiate_stk_push(
            phone_number=phone_number,
            amount=amount,
            reference=str(subscription_id), # unique to match with callback
            db=db
        )
        logging.info(f"In the initiate_mpesa_payment call, this is the response: \n {response}")
        return response
    except Exception as e:
        print(f"Error initializing payment: {e}")
        raise HTTPException(status_code=500, detail="M-Pesa payment initiaizaion failed")
    

# redirect user to plans
templates = Jinja2Templates(directory=Path(__file__).parent.parent / "templates")

@router.get("/subscription-success", response_class=HTMLResponse)
async def subscription_success_page(request: Request):
    return templates.TemplateResponse("subscription_success.html", {"request": request})



// File: app/routes/user.py
from fastapi import APIRouter, Depends, Request, HTTPException
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.templating import Jinja2Templates
from pathlib import Path
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError, SQLAlchemyError
from app.models.user import User
from app.config.database import get_db, Base
from app.models.otp import OTP
from app.models.subscription import Subscription
from app.auth.security import SECRET_KEY, create_access_token
from app.schemas.user import UserCreate, UserLogin
from app.utils.timezone import utc_to_eat, current_utc_time
from app.config.settings import settings
from pydantic import BaseModel
from datetime import datetime, timezone, timedelta
import pytz, africastalking, subprocess, logging, platform, uuid, socket

router = APIRouter()
eat_timezone = pytz.timezone("Africa/Nairobi")

# init Africa's Talking SDK
username = settings.AFRICAS_TALKING_USERNAME
api_key = settings.AFRICAS_TALKING_API_KEY
africastalking.initialize(username, api_key)
sms = africastalking.SMS


########################################
# User Registration
@router.post("/register")
async def register_user(request: UserCreate, db: Session = Depends(get_db)):
    """
    Register a new user and send OTP for verification.
    """
    logging.info("Registering User")
    existing_user = db.query(User).filter(User.phone_number == request.phone_number).first()

    if existing_user:
        logging.info(f"existing user found in database: {existing_user.phone_number}")
        logging.info("generating new otp ...")
        otp_code = generate_otp()
        logging.info(f"{existing_user.phone_number} OTP: {otp_code}")
        logging.info("Storing otp to database ...")
        store_otp(db, existing_user.phone_number, otp_code)
        logging.info("OTP Stored ...")
        logging.info(f"Sending SMS OTP to user {existing_user.phone_number}")
        #send_otp_sms(existing_user, otp_code)
        logging.info(f"OTP sent to {existing_user.phone_number}")
        return {"message": "User already registered. New OTP sent for verification."}

    try:
        logging.info(f"User not in database ... Adding user: {request.phone_number}")
        user = User(phone_number=request.phone_number, mac_address=request.mac_address)
        db.add(user)
        logging.info("commit to database ...")
        db.commit()
        
        logging.info("Generating OTP ...")
        otp_code = generate_otp()
        logging.info(f"New User {request.phone_number} OTP: {otp_code}")
        logging.info("Storing OTP ...")
        store_otp(db, request.phone_number, otp_code)
        logging.info("OTP Stored ...")
        logging.info("Sending OTP Via SMS ...")
        #send_otp_sms(request.phone_number, otp_code)
        logging.info("SMS Sent ...")
        return {"message": "Registration initiated. OTP sent for verification."}
    
    except Exception as e:
        logging.error(f"Error during user registration: {e}")
        raise HTTPException(status_code=500, detail="An unexpected error occurred.")

####################################################

# RETURNING USERS #

@router.post("/login")
async def login_user(phone_number: UserLogin, db: Session = Depends(get_db)):
    # Check if the user is registered
    user = db.query(User).filter(User.phone_number == phone_number.phone_number).first()
    if not user:
        logging.info(f"user: {phone_number.phone_number}")
        raise HTTPException(status_code=400, detail="User not registered")

    # Generate and store OTP
    otp_code = generate_otp()
    store_otp(db, phone_number, otp_code)
    print(f"Returning OTP:{otp_code}\n")
    #send_otp_sms(phone_number, otp_code)
    return {"message": "OTP sent to your phone"}

########################################
# check us's subscpion
@router.get("/check-subscription")
async def check_subscription_status(user_id: int, db: Session = Depends(get_db)):
    """
    Endpoint to check if a user has an active subscription.
    """
    try:
        subscription = db.query(Subscription).filter(
            Subscription.user_id == user_id,
            Subscription.is_active == True,
            Subscription.end_time > datetime.now(timezone.utc)
        ).first()

        if subscription:
            # just make sure of timezone awareness here.
            if subscription.end_time.tzinfo is None:
                subscription.end_time = subscription.end_time.replace(tzinfo=timezone.utc)
                
            time_left = (subscription.end_time - current_utc_time()).total_seconds()
            return {"subscription_active": True, "time_left": max(time_left, 0)}
        else:
            return {"subscription_active": False, "time_left": 0}

    except SQLAlchemyError as e:
        logging.error(f"Database error while checking subscription for user {user_id}: {e}")
        return JSONResponse(status_code=500, content={"detail": "Error checking subscription status"})
    except Exception as e:
        logging.error(f"Unexpected error for user {user_id}: {e}")
        return JSONResponse(status_code=500, content={"detail": "Unexpected server error"})


#######################################
# verify user's otp
class OtpRight (BaseModel):
    phone_number: str
    otp_code: str
@router.post("/verify-otp")
async def verify_otp(re: OtpRight, db: Session = Depends(get_db)):
    
    print("verifying otp...")
    # Validate OTP
    otp = db.query(OTP).filter(
        OTP.phone_number == re.phone_number,
        OTP.otp_code == re.otp_code,
        OTP.is_used == False
    ).first()

    if not otp:
        logging.warning(f"Invalid OTP attempt for phone number: {re.phone_number}")
        raise HTTPException(status_code=400, detail="Invalid or expired OTP")
    
    # Mark OTP as used
    otp.is_used = True
    db.commit()
    logging.info(f"OTP {re.otp_code} for phone number {re.phone_number} marked as used.")

    # Fetch the user
    user = db.query(User).filter(User.phone_number == re.phone_number).first()
    if not user:
        logging.error(f"User not found for phone number: {re.phone_number}")
        raise HTTPException(status_code=404, detail="User not registered")
    logging.info(f"User {user.id} found for phone number {re.phone_number}")

    # Check for an active subscription
    active_subscription = db.query(Subscription).filter(
        Subscription.user_id == user.id,
        Subscription.is_active == True,
        Subscription.end_time > datetime.now(timezone.utc)
    ).first()

    # Prepare session data
    if active_subscription:
        time_left = (active_subscription.end_time - datetime.now(timezone.utc)).total_seconds()
        session_data = {
            "sub": user.phone_number,
            "message": "Enjoying your Internet?",
            "subscription_active": True,
            "time_left": time_left,
            "plan_type": active_subscription.plan_type,
            "user_id": user.id
        }
        logging.info(f"Active subscription found for user {user.id}. Time left: {time_left}s")
    else:
        session_data = {
            "sub": user.phone_number,
            "message": "Welcome back!",
            "subscription_active": user.is_active,
            "user_id": user.id
        }
        logging.info(f"No active subscription found for user {user.id}.")

    # Generate and return token
    logging.info("generating user access token ...")
    token = create_access_token(session_data)
    logging.info(f"Token generated for user {user.id}.")
    return {"access_token": token, "message": session_data["message"]}

#######################################

# serve the OTP verification templates back using a GET route
templates = Jinja2Templates(directory=Path(__file__).parent.parent / "templates")

@router.get("/otp-verification", response_class=HTMLResponse)
async def otp_verification_page(request: Request):
    return templates.TemplateResponse("otp_verification.html", {"request": request})


@router.get("/log-in", response_class=HTMLResponse)
async def returnlogin(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})
#######################################

# Generate 6 figure OTP
def generate_otp():
    # Generate 6-digit OTP
    import random
    otp = random.randint(100000, 999999)
    print("Generated The OTP\n")
    return otp


#Store OTP in Database
def store_otp(db, phone_number: str, otp_code: str):
    """
    store the generated otp to db forspecific number
    """
    try:
        otp = OTP(
            phone_number=phone_number, 
            otp_code=otp_code, 
            is_used=False, 
            created_at=current_utc_time(), 
        )
        db.add(otp)
        db.commit()
        logging.info("CONFIRMED: OTP STORED SUCCESS ...")
    except Exception as e:
        db.rollback()
        print(f"Error storing OTP: {e}")
        raise


#Send OTP SMS
def send_otp_sms(phone_number: str, otp_code: str):
    logging.info(f"Trying to send OTP: {otp_code} ...")
    message = f"""
    Thank you for choosing Safariconnect 
    Your one time OTP code is: {otp_code}
    """
    try:
        response = sms.send(message, [phone_number])
        return response
    except Exception as e:
        raise HTTPException(status_code=500, detail="Failed to send SMS")



def get_mac_from_ip(ip_address):
    """
    Attempt to retrieve MAC address for a given IP address using multiple methods.
    
    Args:
        ip_address (str): IP address to find MAC for
    
    Returns:
        str: MAC address if found, None otherwise
    """
    try:
        # Method 1: Use system-specific ARP commands
        os_system = platform.system().lower()
        
        if os_system == 'windows':
            try:
                # Windows ARP command
                result = subprocess.run(['arp', '-a', ip_address], 
                                        capture_output=True, 
                                        text=True, 
                                        timeout=5)
                # Parse ARP output to extract MAC
                for line in result.stdout.split('\n'):
                    if ip_address in line:
                        # Extract MAC address (typically in format xx-xx-xx-xx-xx-xx)
                        mac = line.split()[-1].replace('-', ':')
                        if mac and len(mac.split(':')) == 6:
                            return mac
            except Exception as e:
                logging.error(f"Windows ARP lookup failed: {e}")
        
        elif os_system in ['linux', 'darwin']:  # Linux or macOS
            try:
                # Linux/macOS ARP command
                result = subprocess.run(['arp', '-n', ip_address], 
                                        capture_output=True, 
                                        text=True, 
                                        timeout=5)
                # Parse ARP output to extract MAC
                for line in result.stdout.split('\n'):
                    if ip_address in line:
                        # Extract MAC address (typically in format xx:xx:xx:xx:xx:xx)
                        parts = line.split()
                        mac = parts[2] if len(parts) > 2 else None
                        if mac and len(mac.split(':')) == 6:
                            return mac
            except Exception as e:
                logging.error(f"Linux/macOS ARP lookup failed: {e}")
        
        # Method 2: Fallback to UUID (if above methods fail)
        # This will return a pseudo-MAC based on the system's UUID
        if ip_address == '127.0.0.1' or ip_address == '::1':
            return str(uuid.getnode())
        
        # Additional fallback: Try socket method
        try:
            hostname = socket.gethostbyaddr(ip_address)[0]
            # Attempt to get MAC via hostname (not reliable for remote IPs)
            mac = ':'.join(['{:02x}'.format((uuid.getnode() >> elements) & 0xff) 
                            for elements in range(0,2*6,2)][::-1])
            return mac
        except Exception as e:
            logging.error(f"Hostname MAC lookup failed: {e}")
        
        return None
    
    except Exception as e:
        logging.error(f"Unexpected error in get_mac_from_ip: {e}")
        return None
    


// File: app/schemas/payment.py
from pydantic import BaseModel

class PaymentCallback(BaseModel):
    checkout_id: str
    status: str
    amount: float




// File: app/schemas/subscription.py
from pydantic import BaseModel

class SubscriptionCreate(BaseModel):
    user_id: int
    plan_type: str




// File: app/schemas/user.py
from pydantic import BaseModel, Field

class UserCreate(BaseModel):
    phone_number: str
    mac_address: str

class UserLogin(BaseModel):
    phone_number: str = Field(..., pattern=r"^\+254\d{9}$")



// File: app/services/mpesa_services.py
import requests
from app.config.settings import settings
from datetime import datetime, timedelta
from fastapi import Depends, HTTPException
from app.config.database import get_db
from app.models.payment_record import PaymentRecord
from app.config.settings import settings
from sqlalchemy.orm import Session
from sqlalchemy import engine
from datetime import datetime
from sqlalchemy.orm import Session, sessionmaker
import logging, json, base64, httpx, time


access_token = None
access_token_expiry = datetime.min

async def initiate_stk_push(phone_number: str, amount: float, reference: str, db: Session = Depends(get_db)):
        """Initiate STK push to customer's phone"""
        #phone number formating for safaricom API
        if phone_number.startswith("+"):
            phone_number = phone_number[1:]  # Remove leading '+'
        elif phone_number.startswith("0"):
            phone_number = f"254{phone_number[1:]}"  # Convert '0' to '254'
            
        access_token = await get_access_token()
        password, timestamp = generate_password()
        
        logging.info(f"Access Token Retrieved: {access_token}")
        
        if not access_token:
            logging.error("Access token was not obtained.")
            raise HTTPException(status_code=500, detail="Failed to obtain access token")
        
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {access_token}",
        }
        
        payload = {
            "BusinessShortCode": settings.M_PESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": int(amount),
            "PartyA": phone_number,
            "PartyB": settings.M_PESA_SHORTCODE,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.CALLBACK_URL,
            "AccountReference": f"Safari Connect. Session_ID: {reference}",
            "TransactionDesc": f"Payment for internet Subscription"
        }
        
        logging.info(f"Payload sent to M-Pesa: {json.dumps(payload, indent=4)}")
        
        try:
            async with httpx.AsyncClient() as client:
                response = requests.post(
            'https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest',
            headers=headers,
            json=payload
        )            
            if response.status_code != 200:
                logging.error(f"M-Pesa API Error: {response.status_code} - {response.text}")
                raise HTTPException(status_code=400, detail="Failed to initiate payment")
            
            # Log the successful response
            #store data
            response_data = response.json()
            logging.info(f"M-Pesa Response: {response.json()}\n")
            logging.info("Seraching for CheckoutRequestID\n")
            checkout_id = response_data.get('CheckoutRequestID')
            
            if not checkout_id:
                logging.error("No CheckoutRequestID in M-Pesa response.")
                raise HTTPException(status_code=400, detail="Missing checkout ID in M-Pesa response.")
            
            subscription_id = int(reference)
            
            #STORE IT
            logging.info(f"initiating store CheckoutID {checkout_id} to Database ...")
            stored = store_checkout_request(checkout_id, subscription_id, db=db)
            if stored:
                logging.info(f"PaymentRecord stored successfully for CheckoutID: {checkout_id}")
            else:
                logging.error(f"Failed To store Checkot Requestfor CheckoutReaquestID: {checkout_id}")
                raise HTTPException(status_code=400, detail="Failed to store Checkout ID in database")
            
            logging.info("Returning STK PUSH response data ...\n")
            return response_data
        
        except requests.exceptions.RequestException as e:
            logging.error(f"Network error during M-Pesa request: {e}")
            raise HTTPException(status_code=500, detail="Network error during M-Pesa payment initialization")
        except KeyError as e:
            logging.error(f"Key error in M-Pesa response: {e}")
            raise HTTPException(status_code=400, detail="Unexpected M-Pesa response format")
        except Exception as e:
            logging.error(f"General error during M-Pesa payment initialization: {e}")
            raise HTTPException(status_code=500, detail="Unexpected error during payment initialization")

#########################################


def generate_password():
        """Generate the M-Pesa password using the provided passkey"""
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        data_to_encode = f"{settings.M_PESA_SHORTCODE}{settings.M_PESA_PASSKEY}{timestamp}"
        return base64.b64encode(data_to_encode.encode()).decode('utf-8'), timestamp


#########################################


async def get_access_token():
    print(f"creating access toke using \n\t{settings.M_PESA_CONSUMER_SECRET, settings.M_PESA_CONSUMER_KEY}")
    """Get the access token required to make M-Pesa API calls"""
    global access_token, access_token_expiry  # Ensure these are global if used outside this function

    # Check if an access token is already available and still valid
    if access_token and datetime.now() < access_token_expiry:
        return access_token
    

    credentials = base64.b64encode(
        f"{settings.M_PESA_CONSUMER_KEY}:{settings.M_PESA_CONSUMER_SECRET}".encode()
    ).decode('utf-8')
    
    print(f"these are the credentials: {credentials}")

    try:
        response = requests.get(
            "https://sandbox.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials",
            headers={"Authorization": f"Basic {credentials}"}
        )

        if response.status_code != 200:
            raise HTTPException(status_code=400, detail="Failed to get access token")

        result = response.json()
        print(f"response from safaricom: \n{result}")
        access_token = result['access_token']  # Ensure this line executes successfully
        # Set token expiry (1 hour)
        access_token_expiry = datetime.now() + timedelta(seconds=3599)
        return access_token
    
    except KeyError as e:
        logging.error(f"Key error in access token response: {e}")
        raise HTTPException(status_code=400, detail="Invalid response format from access token request")
    except Exception as e:
        logging.error(f"Error fetching access token: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch access token")


############################################
def store_checkout_request(checkout_id: str, subscription_id: int, db: Session):
    """
    Store the M-Pesa checkout request in the database.
    """
    
    print(f"Storing checkout request - CheckoutID: {checkout_id}, SubscriptionID: {subscription_id} ...\n")
    
    try:
        payment_record = PaymentRecord(
            checkout_id=checkout_id,
            subscription_id=subscription_id,
            status="Pending"  # Initial status
        )
        db.add(payment_record)
        db.commit()  # Ensure async commit
        db.refresh(payment_record)
        logging.info("Payment initiation record stored successfully ...\n")
        
        return True
    except Exception as e:
        print(f"Failed to store checkout request: {e}")
        raise HTTPException(status_code=500, detail="Failed to store payment record.")


// File: app/static/index.js
let selectedPlan = null;
let currentUserData = null;
let paymentStatusInterval = null;
let isSubscriptionBeingChecked = false;
let requestInProgress = false;
let cancelTokenSource = null;

// Initialize the application
document.addEventListener('DOMContentLoaded', () => {
    clearRedirectionFlag();
    handleDocumentLoad();
});

function handleDocumentLoad() {
    const authToken = localStorage.getItem('authToken');
    authToken ? handleAuthenticatedUser(authToken) : handleUnauthenticatedUser();
}

// Handle authenticated users
function handleAuthenticatedUser(token) {
    console.log("Retrieved token:", token);
    const decodedToken = decodeJwt(token);
    if (!decodedToken || isTokenExpired(decodedToken)) {
        localStorage.removeItem('authToken');
        redirectTo('/user/otp-verification');
        return;
    } else {
        currentUserData = decodedToken;
        handleSubscription();
    }
}

function handleSubscription() {
    if (isSubscriptionBeingChecked) return;

    const subscriptionChecked = localStorage.getItem('subscriptionChecked') === 'true';
    const isSubscriptionActive = localStorage.getItem('subscriptionActive') === 'true';

    if (!subscriptionChecked) {
        isSubscriptionBeingChecked = true;
        checkUserSubscription(currentUserData.user_id)
            .finally(() => finalizeSubscriptionCheck());
    } else if (!isSubscriptionActive) {
        maybeRedirect();
    }
}

// Check subscription status
async function checkUserSubscription(userId) {
    cancelOngoingRequest();
    cancelTokenSource = axios.CancelToken.source();
    try {
        const response = await axios.get(`${API_BASE_URL}/subscription/subscription-status`, {
            params: { user_id: userId },
            headers: getAuthHeaders(),
            cancelToken: cancelTokenSource.token,
        });
        console.log("Subscription Response Data: ", response.data);
        handleSubscriptionResponse(response);
    } catch (error) {
        handleSubscriptionError(error);
    } finally {
        finalizeSubscriptionRequest();
    }
}

// Function to handle the subscription response
function handleSubscriptionResponse(response) {
    const activeSub = response.data.subscription_active;
    const timeLeft = response.data.time_left;
    console.log("Subscription state: ", activeSub);
    console.log("Time left in seconds: ", timeLeft);

    if (activeSub) {
        clearInterval(paymentStatusInterval);
        setSubscriptionActive();
        markSubscriptionChecked();
        showSessionCountdown(timeLeft);
    } else {
        markSubscriptionChecked();
        maybeRedirect();
    }
}

function finalizeSubscriptionCheck() {
    isSubscriptionBeingChecked = false;
}

function maybeRedirect() {
    if (!localStorage.getItem('redirectedOnInactive')) {
        localStorage.setItem('redirectedOnInactive', 'true');
        redirectTo('/subscription/subscription-success');
    }
}

// Ensure to clear redirection flag for a fresh start when user state changes
function clearRedirectionFlag() {
    localStorage.removeItem('redirectedOnInactive');
}

// Handle unauthenticated users
function handleUnauthenticatedUser() {
    const path = window.location.pathname;
    if (path === "/") initRegisterPage();
    else if (path === "/user/otp-verification") initOTPPage();
    else redirectTo('/');
}

// Decode JWT token
function decodeJwt(token) {
    try {
        if (!token || typeof token !== "string") {
            throw new Error("Invalid token");
        }
        const payload = atob(token.split(".")[1].replace(/-/g, "+").replace(/_/g, "/"));
        return JSON.parse(payload);
    } catch (error) {
        console.error("Invalid JWT token:", error);
        return null; // Return null for invalid tokens
    }
}

// Check if the token is expired
function isTokenExpired(decodedToken) {
    return Math.floor(Date.now() / 1000) > decodedToken.exp;
}

// Redirect to a specified path
function redirectTo(path) {
    window.location.href = path;
}

// MArk subscription check storage as true
function markSubscriptionChecked() {
    localStorage.setItem('subscriptionChecked', true);
}

function setSubscriptionActive() {
    localStorage.setItem('subscriptionActive', true);
}


function cancelOngoingRequest() {
    if (cancelTokenSource) {
        cancelTokenSource.cancel('Operation canceled due to new request.');
    }
}


function handleSubscriptionError(error) {
    if (axios.isCancel(error)) {
        console.log('Request canceled:', error.message);
    } else {
        console.error("Error checking subscription:", error);
        showError("Failed to verify subscription. Please try again.");
    }
}

function finalizeSubscriptionRequest() {
    cancelTokenSource = null;
    isSubscriptionBeingChecked = false;
    clearInterval(paymentStatusInterval);
}

// Initialize the registration page
function initRegisterPage() {
    const form = document.querySelector('form');
    form.addEventListener('submit', async (event) => {
        event.preventDefault();
        await registerUser();
    });
}

async function registerUser() {
    const phone = document.getElementById('phone').value;
    const macAddress = await getMacAddress();
    try {
        const response = await axios.post(`${API_BASE_URL}/user/register`, {
            phone_number: phone,
            mac_address: macAddress
        });
        localStorage.setItem('phone_number', phone);
        redirectTo('/user/otp-verification');
    } catch (error) {
        console.error("Registration failed:", error);
        showError("Registration failed. Please try again.");
    }
}

//Subscribe action
document.addEventListener("DOMContentLoaded", function () {
    if (window.location.pathname == "subscription/subscription-success") {
        const planCards = document.querySelectorAll(".plan-card");
        const subscribeButton = document.getElementById("subscribeBtn");

        // Handle plan card selection
        planCards.forEach(function (card) {
            card.addEventListener("click", function () {
                // Deselect other cards
                planCards.forEach(card => card.classList.remove("selected"));
                // Mark the clicked card as selected
                card.classList.add("selected");
                // Show the subscribe button
                subscribeButton.classList.remove("hidden");
            });
        });

        // Handle subscribe button click
        subscribeButton.addEventListener("click", async function () {
            const selectedPlan = document.querySelector(".plan-card.selected");

            if (selectedPlan) {
                const planName = selectedPlan.getAttribute("data-plan");
                console.log("User selected plan:", planName);

                // Send subscription request to the backend
                await subscribe(planName);
            } else {
                console.log("Please select a plan first.");
            }
        });
    }
});

// Function to send the subscription request to the backend
async function subscribe(selectedPlan) {
    if (!selectedPlan) {
        showError("Please select a subscription plan.");
        return;
    }

    if (!currentUser || !currentUser.user_id) {
        showError("User information is missing. Please try re-verifying your OTP.");
        return;
    }

    try {
        const requestData = {
            user_id: currentUser.user_id,
            plan_type: selectedPlan
        };
        console.log("Subscription request data:", requestData);

        const response = await axios.post(`${API_BASE_URL}/subscription/subscribe`, requestData, {
            headers: getAuthHeaders()
        });


        const additionalTime = response.data.time_in_seconds || 0;
        let timeLeft = 0;
        timeLeft += additionalTime;


        if (response.data && response.data.message) {
            showSuccess(response.data.message);
        } else {
            showSuccess("Subscription initiated. Please complete payment on your phone.");
        }

        // Start polling for payment status
        startPaymentStatusPolling();

    } catch (error) {
        // Enhanced error handling
        console.error("Subscription error:", error.response ? error.response.data : error.message);

        // Display user-friendly error message
        if (error.response && error.response.data && error.response.data.detail) {
            showError(error.response.data.detail);
        } else {
            showError("Subscription failed. Please try again.");
        }
    }
}

//getts authentication hedres
function getAuthHeaders() {
    const token = localStorage.getItem("authToken");
    return token ? { Authorization: `Bearer ${token}` } : {};
}

// Start polling every 5 seconds after initiating payment
function startPaymentStatusPolling() {
    if (paymentStatusInterval) {
        clearInterval(paymentStatusInterval);
    }
    if (!isCheckingSubscription) {
        paymentStatusInterval = setInterval(checkUserSubscription, 5000);
    }
}

// Fetch MAC address from the backend
async function getMacAddress() {
    try {
        const response = await axios.get(`${API_BASE_URL}/mac_address/mac-address`);
        return response.data.mac_address || "00:00:00:00:00:00";
    } catch (error) {
        console.error("Failed to retrieve MAC address:", error);
        return "00:00:00:00:00:00";
    }
}

// Initialize the OTP verification page
function initOTPPage() {
    const form = document.querySelector("form");
    const phoneNumberDisplay = document.getElementById("phone-number-display");

    const phoneNumber = localStorage.getItem("phone_number");
    if (phoneNumber && phoneNumberDisplay) {
        phoneNumberDisplay.textContent = phoneNumber;
    }

    form.addEventListener("submit", async (event) => {
        event.preventDefault();
        const otp = document.getElementById("otp").value;

        try {
            const response = await axios.post(`${API_BASE_URL}/user/verify-otp`, {
                phone_number: phoneNumber,
                otp_code: otp,
            });
            const { access_token, message } = response.data;
            localStorage.setItem("authToken", access_token);
            redirectTo('/');
        } catch (error) {
            console.error("OTP verification failed:", error);
            showError("Invalid OTP. Please try again.");
        }
    });
}

// Utility for error messages
function showError(message) {
    console.error(message);
    alert(message); // Simple error alert for now
}

// Utility for success messages
function showSuccess(message) {
    console.log(message);
    alert(message); // Simple success alert for now
}


// Session countdown timer
function showSessionCountdown(timeLeft) {
    const countdownContainer = document.createElement('div');
    countdownContainer.className = 'countdown-container';
    document.body.innerHTML = '';
    document.body.appendChild(countdownContainer);

    const timerText = document.createElement('p');
    countdownContainer.appendChild(timerText);

    const interval = setInterval(() => {
        if (timeLeft <= 0) {
            clearInterval(interval);
            showError("Session expired.");
        } else {
            const hours = Math.floor(timeLeft / 3600);
            const minutes = Math.floor((timeLeft % 3600) / 60);
            const seconds = timeLeft % 60;
            timerText.textContent = `Time left: ${hours}h ${minutes}m ${seconds}s`;
            timeLeft--;
        }
    }, 1000);
}

// File: app/utils/timezone.py
# app/utils/timezone.py
from datetime import datetime, timezone
import pytz

def current_utc_time():
    return datetime.now().replace(tzinfo=timezone.utc)

def utc_to_eat(utc_time):
    eat_time_zone = pytz.timezone('Africa/Nairobi')
    return utc_time.astimezone(eat_time_zone)


// File: initserver.py
import socket
import os
import subprocess
import time
import json

def get_address():
    """Retrieve the IPv4 address of the active network interface."""
    try:
        hostname = socket.gethostname()
        local_address = socket.gethostbyname(hostname)

        if local_address.startswith("127."):
            # use socket lib to look at available interfaces
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.connect(("192.168.0.1", 80))
                local_address = s.getsockname()[0]
        return local_address
    except Exception as e:
        print(f"Error getting IPV4 address: {e}")
        return None


def update_env(local_address, ngrok_link):
    """Update the .env file with the provided IPv4 and callback URL."""
    env_file_path = ".env"
    db_url = f'DATABASE_URL="postgresql://safariconnect:1Amodung%40%21.@{local_address}:5432/safaridb"\n'
    cb_url = f'CALLBACK_URL="{ngrok_link}/payment/mpesa/callback"\n'
    ngrok = f'NGROK_URL="{ngrok_link}"\n'
    ipv4_ip = f'IPV4_CURRENT="http://{local_address}:8000"\n'

    if not os.path.exists(env_file_path):
        with open(env_file_path, 'w') as env_file:
            env_file.writelines([db_url, cb_url, ngrok])
        return

    with open(env_file_path, 'r') as env_file:
        lines = env_file.readlines()

    with open(env_file_path, 'w') as env_file:
        for line in lines:
            if line.startswith('DATABASE_URL'):
                env_file.write(db_url)
            elif line.startswith('CALLBACK_URL'):
                env_file.write(cb_url)
            elif line.startswith('NGROK_URL'):
                env_file.write(ngrok)
            elif line.startswith('IPV4_CURRENT'):
                env_file.write(ipv4_ip)
            else:
                env_file.write(line)
                
        if not any(line.startswith('NGROK_URL') for line in lines):
            env_file.write(ngrok)
        elif not any(line.startswith('IPV4_CURRENT') for line in lines):
            env_file.write(ipv4_ip)

def get_ngrok_url():
    """Start ngrok and retrieve the public URL."""
    try:
        process = subprocess.Popen(['ngrok', 'http', '8000'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        for _ in range(20):  # Increased wait time to 20 seconds for Ngrok to fully start
            time.sleep(1)
            output, error = subprocess.Popen(
                ['curl', '--silent', 'http://localhost:4040/api/tunnels'],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE
            ).communicate()

            if error:
                print(f"Error while checking ngrok status: {error.decode('utf-8')}")
                continue

            if output:
                try:
                    tunnels = json.loads(output.decode('utf-8'))
                    for tunnel in tunnels.get("tunnels", []):
                        if "http" in tunnel["public_url"]:
                            process.terminate()  # Clean up ngrok process after success
                            return tunnel["public_url"]
                except (json.JSONDecodeError, KeyError) as e:
                    print(f"Error parsing ngrok response: {e}")
                    continue

        process.terminate()  # Terminate ngrok if no valid URL found
        print("Timeout waiting for ngrok.")
        return None

    except Exception as e:
        print(f"Error starting ngrok: {e}")
        return None

def start_server(local_address):
    """Start the server using Uvicorn."""
    process = subprocess.Popen(
        ["uvicorn", "app.main:app", "--host", local_address, "--port", "8000", "--reload"]
    )
    try:
        process.wait()
    except KeyboardInterrupt:
        print("\nStopping server...")
        process.terminate()
        process.wait()

if __name__ == "__main__":
    ipv4 = get_address()
    ngrok_url = get_ngrok_url()

    if ipv4 and ngrok_url:
        print(f"IPv4: {ipv4}")
        print(f"ngrok: {ngrok_url}")
        update_env(ipv4, ngrok_url)
        start_server(ipv4)
    else:
        print("Failed to retrieve IP address or ngrok URL.")




// File: logic flow.scss
// Step 1: User loads the portal page
displayLoadingPage()

// Step 2: Check if the user has an authentication token
if (hasAuthToken()) {
    // Step 3: Validate the token's expiration
    if (isTokenExpired()) {
        // Token is expired, user needs to verify via OTP
        displayOTPVerificationPage()
        
        // Step 4: Wait for OTP verification response
        if (isOTPVerified()) {
            // Reissue a new authentication token
            token = issueNewAuthToken()
            
            // Check if the user has an active subscription
            if (hasActiveSubscription(token)) {
                // User has a valid subscription
                redirectToCountdownPage(getRemainingSessionTime(token))
            } else {
                // No active subscription found
                redirectToSubscriptionPage()
            }
        } else {
            // OTP verification failed or timed out
            displayError("OTP verification failed. Please try again.")
        }
    } else {
        // Token is valid (not expired)
        if (hasActiveSubscription(getAuthToken())) {
            // User has an active subscription
            redirectToCountdownPage(getRemainingSessionTime(getAuthToken()))
        } else {
            // No active subscription found
            redirectToSubscriptionPage()
        }
    }
} else {
    // No authentication token found, new user or session
    displayRegistrationPage()

    // Step 5: User registers and gets verified via OTP
    if (isRegistrationSuccessful() && isOTPVerified()) {
        // Issue a new token after successful registration and OTP
        token = issueNewAuthToken()

        // Check for active subscription
        if (hasActiveSubscription(token)) {
            redirectToCountdownPage(getRemainingSessionTime(token))
        } else {
            redirectToSubscriptionPage()
        }
    } else {
        // Registration or OTP verification failed
        displayError("Registration or OTP verification failed.")
    }
}

// Helper Functions (Pseudocode)
function hasAuthToken() {
    // Check for the existence of a stored token (e.g., in cookies or session)
}

function isTokenExpired() {
    // Validate if the token has passed its expiration date
}

function isOTPVerified() {
    // Process OTP verification and return the result
}

function issueNewAuthToken() {
    // Create and return a new authentication token
}

function hasActiveSubscription(token) {
    // Check with the backend if the token is linked to an active subscription
}

function getRemainingSessionTime(token) {
    // Fetch and return the remaining session time for the user
}

function displayLoadingPage() {
    // Render a loading animation or screen
}

function displayOTPVerificationPage() {
    // Show OTP input and verification page
}

function displayRegistrationPage() {
    // Display the registration page for new users
}

function redirectToCountdownPage(sessionTime) {
    // Redirect user to the countdown page with the session timer
}

function redirectToSubscriptionPage() {
    // Redirect user to a page to select or renew a subscription
}

function displayError(message) {
    // Show an error message to the user
}

function isRegistrationSuccessful() {
    // Return true if user registration is successful
}


// File: requirements.txt
fastapi
uvicorn
sqlalchemy
psycopg2-binary
africastalking
jwt
python-jose
pydantic
pydantic-settings
pytz
jinja2
httpx