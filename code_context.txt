// File: app/auth/deps.py
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.orm import Session

from app.config.database import get_db
from app.models.user import User
from app.auth.security import SECRET_KEY, ALGORITHM

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token has expired")
    except JWTError:
        raise credentials_exception
    
    print(f"Decoded JWT Payload: {payload}")
    user = db.query(User).filter(User.username == username).first()
    if user:
        print(f"User found: {user.id}")
    else:
        raise credentials_exception
    return user


// File: app/auth/security.py
from datetime import datetime, timedelta
import jwt
from app.config.settings import settings
from app.utils.timezone import current_utc_time, utc_to_eat


# shields
SECRET_KEY = settings.SECRET_KEY
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 1440

def create_access_token(data: dict):
    """Generates access token with set expiry time,
    encryption algorythm and secret key"""
    to_encode = data.copy()
    expire = current_utc_time()  + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def verify_token(token: str):
    """sends back the decoded token data"""
    try:
        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    except jwt.JWTError:
        return None



// File: app/config/database.py
from sqlalchemy import create_engine, inspect
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from app.config.settings import settings

DATABASE_URL = settings.DATABASE_URL
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# create db
def create_database():
    """Ensuring the tables are created only once"""
try:
    inspector = inspect(engine)
    existing_tables = inspector.get_table_names()
    if not existing_tables:  # Check if tables already exist
        print("Setting up database tables...")
        Base.metadata.create_all(bind=engine)
        print("Tables created.")
    else:
        print(f"Database tables already exist: {existing_tables}. Skipping creation")
except Exception as e:
    print(f"Database connection failed: {e}")

# the dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()




// File: app/config/settings.py
from pydantic_settings import BaseSettings

# environment variables
class Settings(BaseSettings):
    SECRET_KEY: str
    DATABASE_URL: str
    M_PESA_CONSUMER_KEY: str  # Changed from MPESA_CONSUMER_KEY
    M_PESA_CONSUMER_SECRET: str  # Changed from MPESA_CONSUMER_SECRET
    M_PESA_PASSKEY: str  # Changed from MPESA_PASSKEY
    M_PESA_SHORTCODE: str  # Changed from MPESA_SHORTCODE
    CALLBACK_URL: str
    NGROK_URL: str

    class Config:
        env_file = ".env"

settings = Settings()

# print("Available environment variables:", os.environ.keys())



// File: app/main.py
from fastapi import FastAPI, Depends, HTTPException, Request
from fastapi.security import OAuth2PasswordBearer
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from pathlib import Path
from app.config.database import create_database
from app.middleware.ip_whitelist import allow_ip_middleware
from app.routes import user, subscription, payment, mac_address
from app.config.settings import settings
from app.auth.deps import get_current_user
import jwt

app = FastAPI()

# Configure templates and static files
app.mount("/static", StaticFiles(directory=Path(__file__).parent / "static"), name="static")
templates = Jinja2Templates(directory=Path(__file__).parent / "templates")

# Configure CORS settings
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Middlewares
app.middleware("http")(allow_ip_middleware)

# Routes
app.include_router(user.router, prefix="/user", tags=["User"])
app.include_router(subscription.router, prefix="/subscription", tags=["Subscription"])
app.include_router(payment.router, prefix="/payment", tags=["Payment"])
app.include_router(mac_address.router, prefix="/mac_address", tags=["MAC Address"])

# Init Db
create_database()

# root of app
@app.get("/")
async def home(request: Request):
    return templates.TemplateResponse("index.html", {"request": request, "ngrok_url": settings.NGROK_URL})

# Check on the Session Token
# dependency function when I need a user session validated

@app.get("/protected-endpoint")
async def protected_route(user:dict = Depends(get_current_user)):
    return {"message": "Access granted", "user": user}



// File: app/middleware/ip_whitelist.py
from fastapi import Request, HTTPException

# whitelisted IP addresses
ALLOWED_CALLBACK_IPS = [
    "196.201.214.200", "196.201.214.206", "196.201.213.114",
    "196.201.214.207", "196.201.214.208", "196.201.213.44",
    "196.201.212.127", "196.201.212.138", "196.201.212.129",
    "196.201.212.136", "196.201.212.74", "196.201.212.69",
    "192.168.0.102"
]

# allow ip to give callback to the API's
async def allow_ip_middleware(request: Request, call_next):
    if request.url.path == "/payment/mpesa/callback" and request.client.host not in ALLOWED_CALLBACK_IPS:
        # raise HTTPException(status_code=403, detail="Access denied: IP not Allowed")
        return await call_next(request)
    return await call_next(request)




// File: app/models/otp.py
from sqlalchemy import Column, Integer, String, Float, DateTime, Boolean
from app.config.database import Base
from datetime import datetime, timezone
from app.utils.timezone import current_utc_time


class OTP(Base):
    __tablename__ = "otps"
    id = Column(Integer, primary_key=True, index=True)
    phone_number = Column(String)
    otp_code = Column(String)
    created_at = Column(DateTime, default=current_utc_time)
    is_used = Column(Boolean, default=False)


// File: app/models/payment_record.py
from sqlalchemy import Column, Integer, String, DateTime, Float
from app.config.database import Base
from app.utils.timezone import current_utc_time


# base mode for Payment record in db
class PaymentRecord(Base):
    __tablename__ = "payment_records"
    id = Column(Integer, primary_key=True, index=True)
    checkout_id = Column(String, unique=True, index=True)  # The M-Pesa transaction ID
    subscription_id = Column(Integer)  # Links to the Subscription table
    status = Column(String, default="Pending")  # Payment status
    amount = Column(Float, nullable=True)
    mpesa_receipt_number = Column(String, nullable=True)
    transaction_date = Column(DateTime, nullable=True)
    phone_number = Column(String, nullable=True)
    created_at = Column(DateTime, default=current_utc_time)




// File: app/models/subscription.py
from sqlalchemy import Column, Integer, String, Float, DateTime, Boolean
from app.config.database import Base

# base model for Subscription in db

class Subscription(Base):
    __tablename__ = "subscriptions"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer)
    plan_type = Column(String)
    amount = Column(Float)
    start_time = Column(DateTime)
    end_time = Column(DateTime)
    is_active = Column(Boolean, default=False)




// File: app/models/user.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean
from datetime import datetime
from app.config.database import Base

# base model for A user in db
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    phone_number = Column(String, unique=True, index=True)
    mac_address = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)
    is_active = Column(Boolean, default=True)




// File: app/routes/mac_address.py
from fastapi import APIRouter, Request, Depends, HTTPException
import subprocess, platform, uuid, socket, logging, asyncio
from app.auth.deps import get_current_user

router = APIRouter()
#Get Client MAC ADDRESS

@router.get("/mac-address")
async def get_mac_address(req: Request, user=Depends(get_current_user)):
    if not isinstance(req, Request):
        logging.error("Received a non-Request object.")
        return {
            "status": "error",
            "message": "Invalid request object"
        }

    try:
        print(f"Request type: {type(req)}")
        client_ip = req.client.host
        logging.info(f"Attempting to retrieve MAC for IP: {client_ip}")
        
        # if async is still waiting ...
        if asyncio.iscoroutinefunction(get_mac_from_ip):
            mac_address = await get_mac_from_ip(client_ip)
        else:
            mac_address = get_mac_from_ip(client_ip)
        
        # Check if MAC address was successfully retrieved; otherwise use fallback
        if not mac_address:
            mac_address = "00:00:00:00:00:00"  # Placeholder for unobtainable MAC
        
        return {
            "status": "success" if mac_address else "error",
            "mac_address": mac_address,
            "client_ip": client_ip
        }
    except Exception as e:
        logging.error(f"Error in MAC address endpoint: {e}")
        return {
            "status": "error",
            "message": "An unexpected error occurred",
            "client_ip": client_ip if 'client_ip' in locals() else "unknown"
        }


#############################################################################
def get_mac_from_ip(ip_address):
    """
    Attempt to retrieve MAC address for a given IP address using multiple methods.
    
    Args:
        ip_address (str): IP address to find MAC for
    
    Returns:
        str: MAC address if found, None otherwise
    """
    try:
        # Method 1: Use system-specific ARP commands
        os_system = platform.system().lower()
        
        if os_system == 'windows':
            try:
                # Windows ARP command
                result = subprocess.run(['arp', '-a', ip_address], 
                                        capture_output=True, 
                                        text=True, 
                                        timeout=5)
                # Parse ARP output to extract MAC
                for line in result.stdout.split('\n'):
                    if ip_address in line:
                        # Extract MAC address (typically in format xx-xx-xx-xx-xx-xx)
                        mac = line.split()[-1].replace('-', ':')
                        if mac and len(mac.split(':')) == 6:
                            return mac
            except Exception as e:
                logging.error(f"Windows ARP lookup failed: {e}")
        
        elif os_system in ['linux', 'darwin']:  # Linux or macOS
            try:
                # Linux/macOS ARP command
                result = subprocess.run(['arp', '-n', ip_address], 
                                        capture_output=True, 
                                        text=True, 
                                        timeout=5)
                # Parse ARP output to extract MAC
                for line in result.stdout.split('\n'):
                    if ip_address in line:
                        # Extract MAC address (typically in format xx:xx:xx:xx:xx:xx)
                        parts = line.split()
                        mac = parts[2] if len(parts) > 2 else None
                        if mac and len(mac.split(':')) == 6:
                            return mac
            except Exception as e:
                logging.error(f"Linux/macOS ARP lookup failed: {e}")
        
        # Method 2: Fallback to UUID (if above methods fail)
        # This will return a pseudo-MAC based on the system's UUID
        if ip_address == '127.0.0.1' or ip_address == '::1':
            logging.warning("Returning local UUID-based MAC, which may not be reliable for client identification.")
            return str(uuid.getnode())
        
        # Additional fallback: Try socket method
        try:
            hostname = socket.gethostbyaddr(ip_address)[0]
            # Attempt to get MAC via hostname (not reliable for remote IPs)
            mac = ':'.join(['{:02x}'.format((uuid.getnode() >> elements) & 0xff) 
                            for elements in range(0,2*6,2)][::-1])
            return mac
        except Exception as e:
            logging.error(f"Hostname MAC lookup failed: {e}")
        
        return None
    
    except Exception as e:
        logging.error(f"Unexpected error in get_mac_from_ip: {e}")
        return None


// File: app/routes/payment.py
from fastapi import APIRouter, Request, Depends, HTTPException
from app.models.payment_record import PaymentRecord
from app.models.subscription import Subscription
from app.config.database import get_db
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
from datetime import datetime, time
import logging, traceback, asyncio

router = APIRouter()


##########################################


##########################################
@router.post("/mpesa/callback")
async def mpesa_callback(request: Request, db: Session = Depends(get_db)):
    logging.info("M-Pesa callback route hit")
    logging.info(f"Received M-Pesa callback request\n.{request}")
    try:
        # Parse JSON payload
        stk_callback_response = await request.json()
        print(f"Parsed JSON payload: {stk_callback_response}")
        result = stk_callback_response.get('Body', {}).get('stkCallback', {})
        # Extract relevant fields from callback
        checkout_id = result.get('CheckoutRequestID')
        result_code = result.get('ResultCode')
        result_desc = result.get('ResultDesc')

        logging.info(f"Extracted Callback Details - CheckoutID: {checkout_id}, ResultCode: {result_code}, ResultDesc: {result_desc}")
        # Check if the ResultCode indicates success
        if result_code == 0:
            logging.info("Payment is successful. Extracting metadata...")

            # Extract metadata items and ensure all fields are available
            metadata = {item['Name']: item.get('Value') for item in result.get('CallbackMetadata', {}).get('Item', [])}
            amount = metadata.get("Amount")
            receipt_number = metadata.get("MpesaReceiptNumber")
            transaction_date_str = metadata.get("TransactionDate")
            phone_number = metadata.get("PhoneNumber")
            # Log extracted metadata
            logging.info(f"Extracted Metadata - Amount: {amount}, ReceiptNumber: {receipt_number}, TransactionDate: {transaction_date_str}, PhoneNumber: {phone_number}")
            # Validate extracted metadata fields
            if not (amount and receipt_number and transaction_date_str and phone_number):
                logging.error("Incomplete metadata in M-Pesa callback.")
                raise HTTPException(status_code=400, detail="Incomplete callback metadata")
            # Ensure `transaction_date_str` is a string, as `strptime` expects a string
            if isinstance(transaction_date_str, int):
                transaction_date_str = str(transaction_date_str)

            # Convert transaction date to datetime object
            try:
                transaction_date = datetime.strptime(transaction_date_str, "%Y%m%d%H%M%S")
            except ValueError as e:
                logging.error(f"Date parsing error: {e}")
                raise HTTPException(status_code=400, detail="Invalid date format in callback")

            # Fetch and proceed update PaymentRecord in the database if the CheckoutID was in there ro begin with
            print("Querying PaymentRecord from database.\n")
            retries = 10
            for attempt in range(retries):
                payment_record = db.query(PaymentRecord).filter(PaymentRecord.checkout_id == checkout_id).first()
                if payment_record:
                    break
                await asyncio.sleep(1)
            else:
                logging.warning(f"No PaymentRecord found for CheckoutID: {checkout_id}")
                raise HTTPException(status_code=404, detail="Payment record not found")
            
            
            print("PaymentRecord found. Updating with transaction details.")
            payment_record.amount = amount
            payment_record.mpesa_receipt_number = receipt_number
            payment_record.transaction_date = transaction_date
            payment_record.phone_number = phone_number
            payment_record.status = "Successful"
            db.commit()
            logging.info("PaymentRecord updated and committed to database.")

            # Activate subscription
            logging.info("Activating subscription for successful payment.")
            activated = await retry_callback_activation(checkout_id, db=db)
            if activated:
                logging.info("Subscription activated successfully.")
                return {"message": "Payment processed successfully"}
            else:
                logging.error("Failed to activate subscription after payment.")
                raise HTTPException(status_code=500, detail="Failed to activate subscription")
        else:
            # Handle failed payment and mark as failed
            logging.info(f"Payment failed with ResultCode: {result_code}. Marking payment as failed.")
            await mark_payment_failed(checkout_id, db)
            return {"message": f"Payment failed: {result_desc}"}
    except KeyError as e:
        logging.error(f"Missing field in callback data: {e}")
        raise HTTPException(status_code=400, detail="Invalid callback data format")
    except SQLAlchemyError as e:
        logging.error(f"Database error in processing callback: {e}")
        raise HTTPException(status_code=500, detail="Database error during callback processing")
    except Exception as e:
        logging.error(f"Unexpected error in callback processing: {e}")
        raise HTTPException(status_code=500, detail="Error processing callback data")


######################################
# handle retries if callback fails.
async def retry_callback_activation(checkout_id: str, db: Session, retries=10, delay=2):
    for attempt in range(1, retries+ 1):
        try:
            result = activate_subscription(checkout_id, db=db)
            if result:
                logging.info(f"Subscription activated on attempt {attempt}.")
                return True
        except Exception as e:
            logging.error(f"Retry {attempt+1} failed: {e}")
            await asyncio.sleep(delay * attempt)
            
    logging.error(f"Failed to activate subscription after {retries} retries.")
    return False


def activate_subscription(checkout_id: str, db: Session):
    """Activate subscription after successful payment"""
    # Retrieve payment record
    payment_record = db.query(PaymentRecord).filter(PaymentRecord.checkout_id == checkout_id).first()
    
    if payment_record:
        # update the subscription status.
        subscription = db.query(Subscription).filter(Subscription.id == payment_record.subscription_id).first()
        if subscription:
            subscription.is_active = True
            db.commit()
            print("Subscription activated")
            return True
        else:
            logging.warning("Subscription Record Pending.. No Found in Database\n")
            raise HTTPException(status_code=400, detail="Subscription status not found on DataBasa\n")


async def mark_payment_failed(checkout_id: str, db: Session):
    """This function will mark the subscription as inactive or pending in case of payment failure."""
    # Retrieve the payment record
    payment_record = db.query(PaymentRecord).filter(PaymentRecord.checkout_id == checkout_id).first()
    
    if payment_record:
        # Update the subscription status as failed
        subscription = db.query(Subscription).filter(Subscription.id == payment_record.subscription_id).first()
        if subscription:
            subscription.is_active = False
            db.commit()
            print("Payment failed, subscription inactive")


// File: app/routes/subscription.py
from fastapi import APIRouter, Depends, Request, HTTPException
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
from app.models.subscription import Subscription
from app.models.user import User
from app.config.database import get_db
from app.services.mpesa_services import initiate_stk_push
from app.utils.timezone import current_utc_time, utc_to_eat
from app.schemas.subscription import SubscriptionCreate
from fastapi.templating import Jinja2Templates
from pathlib import Path
from fastapi.responses import HTMLResponse
from datetime import datetime, timedelta, timezone
import logging

router = APIRouter()

@router.post("/subscribe")
async def create_subscription(request: SubscriptionCreate, db: Session = Depends(get_db)):
    print(f"Received request: {request}")
    print(f"User ID from request: {request.user_id}")
    # Plan configurations
    plans = {
        "1hr": {"amount": 1, "duration": timedelta(hours=1)},
        "2hrs": {"amount": 25, "duration": timedelta(hours=2)},
        "3hrs": {"amount": 35, "duration": timedelta(hours=3)},
        "8hrs": {"amount": 80, "duration": timedelta(hours=8)},
        "12hrs": {"amount": 100, "duration": timedelta(hours=12)},
        "24hrs": {"amount": 150, "duration": timedelta(days=1)},
        "3 days": {"amount": 300, "duration": timedelta(days=3)},
        "1 week": {"amount": 550, "duration": timedelta(weeks=1)},
        "2 weeks": {"amount": 1000, "duration": timedelta(weeks=2)},
        "monthly": {"amount": 1750, "duration": timedelta(days=30)}
    }
    
    if request.plan_type not in plans:
        raise HTTPException(status_code=400, detail="Invalid plan type")
    
    plan = plans[request.plan_type]
    
    try:
        with db.begin():
            subscription = Subscription(
                user_id=request.user_id,
                plan_type=request.plan_type,
                amount=plan["amount"],
                start_time=current_utc_time(),
                end_time=current_utc_time() + plan["duration"],
                is_active=False
            )
        logging.info(f"Created subscription object: {subscription}")
        db.add(subscription)
        db.commit()
    
        # Initiate M-Pesa payment
        response = await initiate_mpesa_payment(subscription.id, plan["amount"], db=db)
        return {"message": "Subscription initiated, payment pending", "mpesa_response": response}
    
    except SQLAlchemyError as e:
        logging.error(f"Database error during subscription creation: {e}")
        raise HTTPException(status_code=500, detail="Database error occurred")
    except Exception as e:
        logging.error(f"Unexpected error during Subscription creation: {e}")
        raise HTTPException(status_code=500, detail="Unexpected server error")


#creating a subscription status checker
@router.get("/subscription-status")
async def subscription_status(user_id: int, db: Session = Depends(get_db)):
    print(f"checking subscription status for user: {user_id}")
    subscription = db.query(Subscription).filter(
        Subscription.user_id == user_id,
        Subscription.is_active == True
    ).first()
    logging.info(f"subscription for {subscription.user_id} is {subscription.is_active}\n")

    # Calculate time left in seconds if there's an active subscription
    if subscription:
        # Ensure `end_time` is timezone-aware
        if subscription.end_time.tzinfo is None:
            subscription.end_time = subscription.end_time.replace(tzinfo=timezone.utc)
        
        time_left = (subscription.end_time - current_utc_time()).total_seconds()
        logging.info(f"Time left for user {user_id}: {time_left} seconds")
        return {"subscription_active": True, "time_left": max(time_left, 0)}
    
    # Return inactive status if no subscription found
    return {"subscription_active": False, "time_left": 0}


def initiate_mpesa_payment(subscription_id: int, amount: float, db: Session):
    # Retrieve the user's phone number from the database
    subscription = db.query(Subscription).filter(Subscription.id == subscription_id).first()
    user = db.query(User).filter(User.id == subscription.user_id).first()
    
    if not user:
        raise HTTPException(status_code=404, detail="user not found")
    
    phone_number = user.phone_number
    
    try:
        # STK PUSH INITIATE
        print("Initiating Mpesa STK Push Now")
        response = initiate_stk_push(
            phone_number=phone_number,
            amount=amount,
            reference=str(subscription_id), # unique to match with callback
            db=db
        )
        logging.info(f"In the initiate_mpesa_payment call, this is the response: \n {response}")
        return response
    except Exception as e:
        print(f"Error initializing payment: {e}")
        raise HTTPException(status_code=500, detail="M-Pesa payment initiaizaion failed")
    

# redirect user to plans
templates = Jinja2Templates(directory=Path(__file__).parent.parent / "templates")

@router.get("/subscription-success", response_class=HTMLResponse)
async def subscription_success_page(request: Request):
    return templates.TemplateResponse("subscription_success.html", {"request": request})



// File: app/routes/user.py
from fastapi import APIRouter, Depends, Request, HTTPException
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.templating import Jinja2Templates
from pathlib import Path
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError, SQLAlchemyError
from app.models.user import User
from app.config.database import get_db, Base
from app.models.otp import OTP
from app.models.subscription import Subscription
from app.auth.security import SECRET_KEY, create_access_token
from app.schemas.user import UserCreate, UserLogin
from app.utils.timezone import utc_to_eat, current_utc_time
from pydantic import BaseModel
from datetime import datetime, timezone, timedelta
import pytz, africastalking, jwt, subprocess, logging, platform, uuid, socket

router = APIRouter()
eat_timezone = pytz.timezone("Africa/Nairobi")

africastalking.initialize(
    username='sandbox',
    api_key='atsk_2c126971a075f8c3ed0dbab580d1e4cb7959577587717d23e5fca0b6387104f4e7079690'
)
sms = africastalking.SMS


########################################
# register user
@router.post("/register")
async def register_user(request: UserCreate, db: Session = Depends(get_db)):
    # Check if the user already exists
    print("Regisering User\n")
    existing_user = db.query(User).filter(User.phone_number == request.phone_number).first()
    if existing_user:
        # Resend OTP for the existing user
        print("Calling OTP Verification\n")
        otp_code = generate_otp()
        print(f"YOUR OTP: {otp_code}")
        store_otp(db, request.phone_number, otp_code)
        send_otp_sms(request.phone_number, otp_code)
        return {"message": "User already registered. New OTP sent for verification."}
    else:
        print("Database issues\n")

    # If user does not exist, proceed to create a new entry
    try:
        user = User(phone_number=request.phone_number, mac_address=request.mac_address)
        with db.begin():
            db.add(user)
            db.commit()

        # Generate and send OTP for the new registration
        otp_code = generate_otp()
        print(f"otp: {otp_code}")
        logging.info(f"OTP for {request.phone_number}: {otp_code}")
        store_otp(db, request.phone_number, otp_code)
        send_otp_sms(request.phone_number, otp_code)

        return {"message": "Registration initiated. OTP sent for verification."}
    except IntegrityError as e:
        db.rollback()
        logging.error(f"IntegrityError while adding user {request.phone_number}: {e}")
        raise HTTPException(status_code=400, detail="User already exists or registration failed.")
    except Exception as e:
        logging.error(f"Unexpected error during user registration: {e}")
        raise HTTPException(status_code=500, detail="An unexpected error occurred.")
####################################################

# RETURNING USERS #

@router.post("/login")
async def login_user(phone_number: UserLogin, db: Session = Depends(get_db)):
    # Check if the user is registered
    user = db.query(User).filter(User.phone_number == phone_number.phone_number).first()
    if not user:
        logging.info(f"user: {phone_number.phone_number}")
        raise HTTPException(status_code=400, detail="User not registered")

    # Generate and store OTP
    otp_code = generate_otp()
    store_otp(db, phone_number, otp_code)
    print(f"Returning OTP:{otp_code}\n")
    send_otp_sms(phone_number, otp_code)
    return {"message": "OTP sent to your phone"}

########################################
# check us's subscpion
@router.get("/check-subscription")
async def check_subscription_status(user_id: int, db: Session = Depends(get_db)):
    """
    Endpoint to check if a user has an active subscription.
    """
    try:
        subscription = db.query(Subscription).filter(
            Subscription.user_id == user_id,
            Subscription.is_active == True,
            Subscription.end_time > datetime.now(timezone.utc)
        ).first()

        if subscription:
            # just make sure of timezone awareness here.
            if subscription.end_time.tzinfo is None:
                subscription.end_time = subscription.end_time.replace(tzinfo=timezone.utc)
                
            time_left = (subscription.end_time - current_utc_time()).total_seconds()
            return {"subscription_active": True, "time_left": max(time_left, 0)}
        else:
            return {"subscription_active": False, "time_left": 0}

    except SQLAlchemyError as e:
        logging.error(f"Database error while checking subscription for user {user_id}: {e}")
        return JSONResponse(status_code=500, content={"detail": "Error checking subscription status"})
    except Exception as e:
        logging.error(f"Unexpected error for user {user_id}: {e}")
        return JSONResponse(status_code=500, content={"detail": "Unexpected server error"})


#######################################
# verify user's otp
class OtpRight (BaseModel):
    phone_number: str
    otp_code: str
@router.post("/verify-otp")
async def verify_otp(re: OtpRight, db: Session = Depends(get_db)):
    
    print("verifying otp...")
    # Validate OTP
    otp = db.query(OTP).filter(
        OTP.phone_number == re.phone_number,
        OTP.otp_code == re.otp_code,
        OTP.is_used == False
    ).first()

    if not otp:
        logging.warning(f"Invalid OTP attempt for phone number: {re.phone_number}")
        raise HTTPException(status_code=400, detail="Invalid or expired OTP")
    
    # Mark OTP as used
    otp.is_used = True
    db.commit()
    logging.info(f"OTP {re.otp_code} for phone number {re.phone_number} marked as used.")

    # Fetch the user
    user = db.query(User).filter(User.phone_number == re.phone_number).first()
    if not user:
        logging.error(f"User not found for phone number: {re.phone_number}")
        raise HTTPException(status_code=404, detail="User not registered")
    logging.info(f"User {user.id} found for phone number {re.phone_number}")

    # Check for an active subscription
    active_subscription = db.query(Subscription).filter(
        Subscription.user_id == user.id,
        Subscription.is_active == True,
        Subscription.end_time > datetime.now(timezone.utc)
    ).first()

    # Prepare session data
    if active_subscription:
        time_left = (active_subscription.end_time - datetime.now(timezone.utc)).total_seconds()
        session_data = {
            "sub": user.phone_number,
            "message": "Enjoying your Internet?",
            "subscription_active": True,
            "time_left": time_left,
            "plan_type": active_subscription.plan_type,
            "user_id": user.id
        }
        logging.info(f"Active subscription found for user {user.id}. Time left: {time_left}s")
    else:
        session_data = {
            "sub": user.phone_number,
            "message": "Welcome back!",
            "subscription_active": False,
            "user_id": user.id
        }
        logging.info(f"No active subscription found for user {user.id}.")

    # Generate and return token
    token = create_access_token(session_data)
    logging.info(f"Token generated for user {user.id}.")
    return {"token": token, "message": session_data["message"]}

#######################################

# serve the OTP verification templates back using a GET route
templates = Jinja2Templates(directory=Path(__file__).parent.parent / "templates")

@router.get("/otp-verification", response_class=HTMLResponse)
async def otp_verification_page(request: Request):
    return templates.TemplateResponse("otp_verification.html", {"request": request})


@router.get("/log-in", response_class=HTMLResponse)
async def returnlogin(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})
#######################################

# Generate 6 figure OTP
def generate_otp():
    # Generate 6-digit OTP
    import random
    otp = random.randint(100000, 999999)
    print("Generated The OTP\n")
    return otp


#Store OTP in Database
def store_otp(db: Session, phone_number: str, otp_code: str):
    otp = OTP(phone_number=phone_number, otp_code=otp_code, is_used=False, created_at=current_utc_time())
    db.add(otp)
    db.commit()


#Send OTP SMS
def send_otp_sms(phone_number: str, otp_code: str):
    message = f"Your OTP code is: {otp_code}"
    try:
        response = sms.send(message, [phone_number])
        return response
    except Exception as e:
        raise HTTPException(status_code=500, detail="Failed to send SMS")



def get_mac_from_ip(ip_address):
    """
    Attempt to retrieve MAC address for a given IP address using multiple methods.
    
    Args:
        ip_address (str): IP address to find MAC for
    
    Returns:
        str: MAC address if found, None otherwise
    """
    try:
        # Method 1: Use system-specific ARP commands
        os_system = platform.system().lower()
        
        if os_system == 'windows':
            try:
                # Windows ARP command
                result = subprocess.run(['arp', '-a', ip_address], 
                                        capture_output=True, 
                                        text=True, 
                                        timeout=5)
                # Parse ARP output to extract MAC
                for line in result.stdout.split('\n'):
                    if ip_address in line:
                        # Extract MAC address (typically in format xx-xx-xx-xx-xx-xx)
                        mac = line.split()[-1].replace('-', ':')
                        if mac and len(mac.split(':')) == 6:
                            return mac
            except Exception as e:
                logging.error(f"Windows ARP lookup failed: {e}")
        
        elif os_system in ['linux', 'darwin']:  # Linux or macOS
            try:
                # Linux/macOS ARP command
                result = subprocess.run(['arp', '-n', ip_address], 
                                        capture_output=True, 
                                        text=True, 
                                        timeout=5)
                # Parse ARP output to extract MAC
                for line in result.stdout.split('\n'):
                    if ip_address in line:
                        # Extract MAC address (typically in format xx:xx:xx:xx:xx:xx)
                        parts = line.split()
                        mac = parts[2] if len(parts) > 2 else None
                        if mac and len(mac.split(':')) == 6:
                            return mac
            except Exception as e:
                logging.error(f"Linux/macOS ARP lookup failed: {e}")
        
        # Method 2: Fallback to UUID (if above methods fail)
        # This will return a pseudo-MAC based on the system's UUID
        if ip_address == '127.0.0.1' or ip_address == '::1':
            return str(uuid.getnode())
        
        # Additional fallback: Try socket method
        try:
            hostname = socket.gethostbyaddr(ip_address)[0]
            # Attempt to get MAC via hostname (not reliable for remote IPs)
            mac = ':'.join(['{:02x}'.format((uuid.getnode() >> elements) & 0xff) 
                            for elements in range(0,2*6,2)][::-1])
            return mac
        except Exception as e:
            logging.error(f"Hostname MAC lookup failed: {e}")
        
        return None
    
    except Exception as e:
        logging.error(f"Unexpected error in get_mac_from_ip: {e}")
        return None
    


// File: app/schemas/payment.py
from pydantic import BaseModel

class PaymentCallback(BaseModel):
    checkout_id: str
    status: str
    amount: float




// File: app/schemas/subscription.py
from pydantic import BaseModel

class SubscriptionCreate(BaseModel):
    user_id: int
    plan_type: str




// File: app/schemas/user.py
from pydantic import BaseModel, Field

class UserCreate(BaseModel):
    phone_number: str
    mac_address: str

class UserLogin(BaseModel):
    phone_number: str = Field(..., pattern=r"^\+254\d{9}$")



// File: app/services/mpesa_services.py
import requests
from app.config.settings import settings
from datetime import datetime, timedelta
from fastapi import Depends, HTTPException
from app.config.database import get_db
from app.models.payment_record import PaymentRecord
from app.config.settings import settings
from sqlalchemy.orm import Session
from sqlalchemy import engine
from datetime import datetime
from sqlalchemy.orm import Session, sessionmaker
import logging, json, base64, httpx, time


access_token = None
access_token_expiry = datetime.min

async def initiate_stk_push(phone_number: str, amount: float, reference: str, db: Session = Depends(get_db)):
        """Initiate STK push to customer's phone"""
        #phone number formating for safaricom API
        if phone_number.startswith("+"):
            phone_number = phone_number[1:]  # Remove leading '+'
        elif phone_number.startswith("0"):
            phone_number = f"254{phone_number[1:]}"  # Convert '0' to '254'
            
        access_token = await get_access_token()
        password, timestamp = generate_password()
        
        print(f"Access Token Retrieved: {access_token}")
        
        if not access_token:
            logging.error("Access token was not obtained.")
            raise HTTPException(status_code=500, detail="Failed to obtain access token")
        
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {access_token}",
        }
        
        payload = {
            "BusinessShortCode": settings.M_PESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": int(amount),
            "PartyA": phone_number,
            "PartyB": settings.M_PESA_SHORTCODE,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.CALLBACK_URL,
            "AccountReference": f"Safari Connect. Session_ID: {reference}",
            "TransactionDesc": f"Payment for internet Subscription"
        }
        
        print(f"Payload sent to M-Pesa: {json.dumps(payload, indent=4)}")
        
        try:
            async with httpx.AsyncClient() as client:
                response = requests.post(
            'https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest',
            headers=headers,
            json=payload
        )            
            if response.status_code != 200:
                logging.error(f"M-Pesa API Error: {response.status_code} - {response.text}")
                raise HTTPException(status_code=400, detail="Failed to initiate payment")
            
            # Log the successful response
            print(f"Response after Payload: \n\t{response.json()}")
            #store data
            response_data = response.json()
            logging.info(f"M-Pesa Response: {response.json()}")
            checkout_id = response_data.get('CheckoutRequestID')
            
            if not checkout_id:
                logging.error("No CheckoutRequestID in M-Pesa response.")
                raise HTTPException(status_code=400, detail="Missing checkout ID in M-Pesa response.")
            
            subscription_id = int(reference)
            
            #STORE IT
            storeed = store_checkout_request(checkout_id, subscription_id, db=db)
            if storeed:
                logging.info(f"PaymentRecord stored successfully for CheckoutID: {checkout_id}")
            else:
                logging.error(f"Failed To store Checkot Requestfor CheckoutReaquestID: {checkout_id}")
                raise HTTPException(status_code=400, detail="Failed to store Checkout ID in database")
            
            return response_data
        
        except requests.exceptions.RequestException as e:
            logging.error(f"Network error during M-Pesa request: {e}")
            raise HTTPException(status_code=500, detail="Network error during M-Pesa payment initialization")
        except KeyError as e:
            logging.error(f"Key error in M-Pesa response: {e}")
            raise HTTPException(status_code=400, detail="Unexpected M-Pesa response format")
        except Exception as e:
            logging.error(f"General error during M-Pesa payment initialization: {e}")
            raise HTTPException(status_code=500, detail="Unexpected error during payment initialization")

#########################################


def generate_password():
        """Generate the M-Pesa password using the provided passkey"""
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        data_to_encode = f"{settings.M_PESA_SHORTCODE}{settings.M_PESA_PASSKEY}{timestamp}"
        return base64.b64encode(data_to_encode.encode()).decode('utf-8'), timestamp


#########################################


async def get_access_token():
    print(f"creating access toke using \n\t{settings.M_PESA_CONSUMER_SECRET, settings.M_PESA_CONSUMER_KEY}")
    """Get the access token required to make M-Pesa API calls"""
    global access_token, access_token_expiry  # Ensure these are global if used outside this function

    # Check if an access token is already available and still valid
    if access_token and datetime.now() < access_token_expiry:
        return access_token
    

    credentials = base64.b64encode(
        f"{settings.M_PESA_CONSUMER_KEY}:{settings.M_PESA_CONSUMER_SECRET}".encode()
    ).decode('utf-8')
    
    print(f"these are the credentials: {credentials}")

    try:
        response = requests.get(
            "https://sandbox.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials",
            headers={"Authorization": f"Basic {credentials}"}
        )

        if response.status_code != 200:
            raise HTTPException(status_code=400, detail="Failed to get access token")

        result = response.json()
        print(f"response from safaricom: \n{result}")
        access_token = result['access_token']  # Ensure this line executes successfully
        # Set token expiry (1 hour)
        access_token_expiry = datetime.now() + timedelta(seconds=3599)
        return access_token
    
    except KeyError as e:
        logging.error(f"Key error in access token response: {e}")
        raise HTTPException(status_code=400, detail="Invalid response format from access token request")
    except Exception as e:
        logging.error(f"Error fetching access token: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch access token")


############################################
def store_checkout_request(checkout_id: str, subscription_id: int, db: Session):
    """
    Store the M-Pesa checkout request in the database.
    """
    
    print(f"Storing checkout request - CheckoutID: {checkout_id}, SubscriptionID: {subscription_id}")
    
    try:
        payment_record = PaymentRecord(
            checkout_id=checkout_id,
            subscription_id=subscription_id,
            status="Pending"  # Initial status
        )
        db.add(payment_record)
        db.commit()  # Ensure async commit
        db.refresh(payment_record)
        print("Payment stored successfully")
        
        return True
    except Exception as e:
        print(f"Failed to store checkout request: {e}")
        raise HTTPException(status_code=500, detail="Failed to store payment record.")


// File: app/static/index.js
const API_BASE_URL = "{{ ngrok_url }}";
console.log("API Base URL:", API_BASE_URL);
let selectedPlan = null;
let currentUser = null;
let paymentStatusInterval = null;
let countdownInterval = null;

document.addEventListener('DOMContentLoaded', () => {
    console.log("Document loaded, checking for authentication token...");
    const token = localStorage.getItem('authToken');
    const path = window.location.pathname;

    if (token) {
        console.log("Token found. Decoding...");
        const decodedToken = decodeJwt(token);

        if (!decodedToken) {
            console.error("Failed to decode token. Redirecting to OTP verification...");
            localStorage.removeItem('authToken');
            window.location.href = '/user/otp-verification';
            return;
        }

        console.log("Decoded Token:", decodedToken);

        if (isTokenExpired(decodedToken)) {
            console.warn("Token is expired. Removing token and redirecting to OTP verification...");
            localStorage.removeItem('authToken');
            window.location.href = '/user/otp-verification';
        } else {
            console.log("Token is valid. Proceeding with user session...");
            currentUser = decodedToken;
            checkUserSubscription(decodedToken);
        }
    } else {
        console.warn("No token found. Handling paths for unauthenticated user...");
        if (path === "/") {
            console.log("Initializing registration page...");
            initRegisterPage();
        } else if (path === "/user/otp-verification") {
            console.log("Initializing OTP verification page...");
            initOTPPage();
        } else {
            console.error("Unhandled path for unauthenticated user. Redirecting to registration...");
            window.location.href = '/';
        }
    }
});

// Utility: Decode JWT to access session data
function decodeJwt(token) {
    try {
        const base64Url = token.split('.')[1];
        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
        const decoded = JSON.parse(atob(base64));
        console.log("Successfully decoded JWT:", decoded);
        return decoded;
    } catch (error) {
        console.error("Error decoding JWT:", error);
        return null;
    }
}

// Utility: Check if token is expired
function isTokenExpired(decodedToken) {
    console.log("Checking token expiry...");
    if (!decodedToken || !decodedToken.exp) return true;
    const currentTime = Math.floor(Date.now() / 1000);
    console.log(`Token expiry time: ${decodedToken.exp}, current time: ${currentTime}`);
    return decodedToken.exp < currentTime;
}

// Helper to get auth headers with token
function getAuthHeaders() {
    const token = localStorage.getItem('authToken');
    if (!token) {
        console.warn("No auth token found. Redirecting to OTP verification...");
        window.location.href = '/user/otp-verification';
        return null;
    }
    return { headers: { Authorization: `Bearer ${token}` } };
}

// Check user's subscription status by calling the backend
async function checkUserSubscription(decodedToken) {
    console.log("Checking user subscription status...");
    try {
        const response = await axios.get(`${API_BASE_URL}/user/check-subscription`, {
            params: { user_id: decodedToken.user_id },
            headers: { Authorization: `Bearer ${localStorage.getItem('authToken')}` }
        });

        console.log("Response:", response);

        if (typeof response.data !== 'object') {
            console.error("Unexpected response format. Received non-JSON response:", response);
            showError("Failed to check subscription status. Please try again later.");
            return;
        }

        console.log("Subscription status response:", response.data);

        if (response.data.subscription_active) {
            console.log("User has an active subscription. Redirecting to countdown page...");
            showSessionCountdown(response.data.time_left);
        } else {
            // Prevent redirect loop if already on the subscription page
            if (window.location.pathname !== '/subscription/subscription-success') {
                console.log("User does not have an active subscription. Redirecting to subscription page...");
                window.location.href = '/subscription/subscription-success';
            } else {
                console.log("Already on the subscription page, not redirecting.");
                initSubscriptionPage();
            }
        }
    } catch (error) {
        console.error("Error while checking subscription status:", error);
        showError("Failed to check subscription status. Please try again.");
    }
}




// 1. Registration and MAC Retrieval
async function initRegisterPage() {
    document.querySelector('form').addEventListener('submit', async (event) => {
        event.preventDefault();
        const phone = document.getElementById('phone').value;
        console.log("Form submitted. Phone number entered:", phone);
        const macAddress = await getMacAddress();

        try {
            console.log("Sending registration request...");
            const response = await axios.post(`${API_BASE_URL}/user/register`, { phone_number: phone, mac_address: macAddress });
            if (response) {
                console.log("Registration successful:", response.data);
                showSuccess(response.data.message || "Registered successfully");
                localStorage.setItem('phone_number', phone);
                setTimeout(5000);
                window.location.href = '/user/otp-verification';
            }
            else {
                console.log("couldn't get response from server\n");
            }
        } catch (error) {
            console.error("Registration failed:", error.response ? error.response.data : error.message);
            showError("Registration failed. Please try again.");
        }
    });
}

// Get MAC Address from backend
async function getMacAddress() {
    try {
        console.log("Fetching MAC address from backend...");
        const response = await axios.get(`${API_BASE_URL}/mac_address/mac-address`, getAuthHeaders());
        console.log("MAC address retrieved:", response.data.mac_address);
        return response.data.mac_address || "MAC not found";
    } catch (error) {
        console.error("Error retrieving MAC address:", error);
        return "Error retrieving MAC";
    }
}

// 2. OTP Verification and Store Token
async function initOTPPage() {
    const otpForm = document.getElementById('otp-form');
    if (otpForm) {
        otpForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const otp = document.getElementById('otp').value;
            const phone = localStorage.getItem('phone_number');
            console.log("OTP form submitted. OTP entered:", otp);

            if (!phone) {
                console.error("Phone number is missing from local storage.");
                showError("Phone number is missing. Please register again.");
                window.location.href = '/';
                return;
            }

            try {
                console.log("Sending OTP verification request...");
                const { data } = await axios.post(`${API_BASE_URL}/user/verify-otp`, { phone_number: phone, otp_code: otp });
                console.log("OTP verified successfully:", data);
                handleOtpSuccess(data);
            } catch (error) {
                console.error("OTP verification failed:", error.response ? error.response.data : error.message);
                handleOtpError(error);
            }
        });
    }
}

function handleOtpSuccess(data) {
    const { token, message } = data;
    if (token) {
        console.log("Storing new auth token and redirecting...");
        localStorage.setItem('authToken', token);
        showSuccess(message || "OTP verified successfully");
        const decodedUser = decodeJwt(token);
        window.location.href = decodedUser.subscription_active ? '/countdown' : '/subscription/subscription-success';
    } else {
        console.warn("No token received from OTP verification.");
    }
}

function handleOtpError(error) {
    console.error("Handling OTP error...");
    showError("Invalid OTP. Please try again.");
}

// 3. Subscription Page Initialization
function initSubscriptionPage() {
    console.log("Initializing subscription page...");
    document.querySelectorAll('.plan-card').forEach(card => {
        card.addEventListener('click', (event) => selectPlan(event, card.getAttribute('data-plan')));
    });
    document.getElementById('subscribeBtn').addEventListener('click', subscribe);
}

// Subscription Plan Selection
function selectPlan(event, plan) {
    console.log(`Plan selected: ${plan}`);
    selectedPlan = plan;
    document.querySelectorAll('.plan-card').forEach(card => card.classList.remove('selected'));
    event.currentTarget.classList.add('selected');
    document.getElementById('subscribeBtn').classList.remove('hidden');
}

// 4. Subscribe to Plan with Authenticated Request
async function subscribe() {
    if (!selectedPlan) {
        showError("Please select a subscription plan.");
        console.warn("Subscription attempt without selecting a plan.");
        return;
    }
    if (!currentUser || !currentUser.user_id) {
        showError("User information is missing. Please verify your OTP.");
        console.error("User data is missing during subscription attempt:", currentUser);
        return;
    }

    try {
        console.log("Sending subscription request...");
        const response = await axios.post(
            `${API_BASE_URL}/subscription/subscribe`,
            { user_id: currentUser.user_id, plan_type: selectedPlan },
            getAuthHeaders()
        );
        console.log("Subscription initiated successfully:", response.data);
        showSuccess(response.data.message || "Subscription initiated. Please complete payment on your phone.");
        startPaymentStatusPolling();
    } catch (error) {
        console.error("Subscription request failed:", error.response ? error.response.data : error.message);
        showError("Subscription failed. Please try again.");
    }
}

// 5. Poll Payment Status until Successful
async function checkPaymentStatus() {
    console.log("Checking payment status...");
    try {
        const response = await axios.get(`${API_BASE_URL}/subscription/subscription-status`, {
            params: { user_id: currentUser.user_id },
            headers: { Authorization: `Bearer ${localStorage.getItem('authToken')}` }
        });
        console.log("Payment status response:", response.data);

        if (response.data.subscription_active) {
            console.log("Subscription is active. Stopping polling...");
            clearInterval(paymentStatusInterval);
            showSuccess("Payment successful. Subscription activated!");
            showSessionCountdown(response.data.time_left);
        } else {
            console.log("Subscription not active yet. Polling continues...");
        }
    } catch (error) {
        console.error("Error while checking payment status:", error);
    }
}

// Start Polling for Payment Status
function startPaymentStatusPolling() {
    console.log("Starting payment status polling...");
    if (paymentStatusInterval) clearInterval(paymentStatusInterval);
    paymentStatusInterval = setInterval(checkPaymentStatus, 5000);
}

// 6. Show Session Countdown Timer
function showSessionCountdown(timeLeft) {
    console.log("Starting session countdown. Time left:", timeLeft);
    const countdownContainer = document.createElement('div');
    countdownContainer.className = 'countdown-container';
    document.querySelector('.container').innerHTML = '';
    document.querySelector('.container').appendChild(countdownContainer);

    countdownContainer.innerHTML = `
        <div class="countdown-container-message">
            <h3>Tik Tok <br> Goes The Clock</h3>
            <p>Enjoy The Internet :)</p>
        </div>
    `;

    const timerText = document.createElement('p');
    timerText.className = 'timer-text';
    countdownContainer.appendChild(timerText);

    const buyMore = document.createElement('button');
    buyMore.className = 'buy-more-button';
    buyMore.textContent = "Buy More Time";
    countdownContainer.appendChild(buyMore);

    const plansContainer = document.createElement('div');
    plansContainer.className = 'plans-container hidden';  // Hidden by default
    plansContainer.innerHTML = `
        <div class="plans">
        <div class="plan-card" data-plan="1hr">
            <h3>1 Hour</h3>
            <p>KSh 10</p>
        </div>
        <div class="plan-card" data-plan="2hrs">
            <h3>2 Hours</h3>
            <p>KSh 20</p>
        </div>
        <div class="plan-card" data-plan="3hrs">
            <h3>3 Hours</h3>
            <p>KSh 30</p>
        </div>
        <div class="plan-card" data-plan="8hrs">
            <h3>8 Hours</h3>
            <p>KSh 80</p>
        </div>
        <div class="plan-card" data-plan="12hrs">
            <h3>12 Hours</h3>
            <p>KSh 100</p>
        </div>
        <div class="plan-card" data-plan="24hrs">
            <h3>24 Hours</h3>
            <p>KSh 150</p>
        </div>
        <div class="plan-card" data-plan="3 days">
            <h3>3 Days</h3>
            <p>KSh 300</p>
        </div>
        <div class="plan-card" data-plan="1 week">
            <h3>1 Week</h3>
            <p>KSh 550</p>
        </div>
        <div class="plan-card" data-plan="2 weeks">
            <h3>2 Weeks</h3>
            <p>KSh 1000</p>
        </div>
        <div class="plan-card" data-plan="monthly">
            <h3>Monthly</h3>
            <p>KSh 1750</p>
        </div>
    </div>
    <button id="subscribeBtn" class="hidden">Subscribe</button>
    `;
    document.querySelector('.container').appendChild(plansContainer);

    buyMore.addEventListener('click', () => {
        console.log("User clicked 'Buy More Time'. Showing available plans...");
        plansContainer.classList.toggle('hidden');
    });

    plansContainer.addEventListener('click', (event) => {
        if (event.target.classList.contains('plan-card')) {
            console.log(`Plan selected: ${event.target.getAttribute('data-plan')}`);
            initSubscriptionPage();
        }
    });

    function updateCountdown() {
        if (timeLeft <= 0) {
            console.warn("Session expired. Redirecting user...");
            clearInterval(countdownInterval);
            countdownContainer.innerHTML = "<p>Session expired. Please select a plan.</p>";
            return;
        }

        const hours = Math.floor(timeLeft / 3600);
        const minutes = Math.floor((timeLeft % 3600) / 60);
        const seconds = Math.floor(timeLeft % 60);
        timerText.textContent = `Session time left: ${hours}h ${minutes}m ${seconds}s`;
        console.log(`Updated countdown: ${hours}h ${minutes}m ${seconds}s`);
        timeLeft--;
    }

    countdownInterval = setInterval(updateCountdown, 1000);
    updateCountdown();
}

// time utilty function
function displayTimeInLocalFormat(utcTime) {
    const date = new Date(utcTime);
    const options = { timeZone: 'Africa/Nairobi', hour12: false };
    console.log(new Intl.DateTimeFormat('en-KE', options).format(date));
}


// Utility Functions for Error/Success Messages
function showError(message) {
    console.error("Displaying error message:", message);
    const error = document.createElement('div');
    error.className = 'error';
    error.textContent = message;
    document.querySelector('.container').appendChild(error);
    setTimeout(() => error.remove(), 3000);
}

function showSuccess(message) {
    console.log("Displaying success message:", message);
    const success = document.createElement('div');
    success.className = 'success';
    success.textContent = message;
    document.querySelector('.container').appendChild(success);
    setTimeout(() => success.remove(), 3000);
}



// File: app/static/style.css
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
}

body {
    background: #f0f2f5;
    color: #1a1a1a;
    line-height: 1.6;
}

.titlename{
    padding-top: 2rem;
}
.page-container {
    position: relative;
    min-height: 100vh;
}

main {
    padding-bottom: 2rem;
}

/* Header and Footer Styling */
#footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 3rem;
    background-color: #1a73e8;
    color: white;
    padding: 1rem;
    text-align: center;
}

/* Container Styling */
.container {
    max-width: 400px;
    margin: 2rem auto;
    padding: 2rem;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    text-align: center;
}

.contdown-container {
    max-width: 400px;
    margin: 2rem auto;
    padding: 1rem;
}

h1, h2, h3 {
    text-align: center;
    color: #1a73e8;
    margin-bottom: 1rem;
}

/*form and input styling*/
label {
    display: block;
    margin: 1rem 0 0.5rem;
    text-align:center;
    color: #666;
}

form {
    text-align: center;
}
input[type="tel"], input[type="text"] {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 1rem;
    margin-bottom: 1rem;
    text-align: center;
}

/*button styling*/
button {
    width: 100%;
    padding: 0.75rem;
    background: #1a73e8;
    color: white;
    border: none;
    border-radius: 4px;
    font-size: 1rem;
    cursor: pointer;
    transition: background 0.3s;
}

button:hover {
    background: #1557b0;
}

a {
    color: #1a73e8;
    text-decoration: none;
    display: inline-block;
    margin-top: 1rem;
}

/* Error and Success Message */
.error {
    color: #d93025;
    margin-top: 0.5rem;
    font-size: 0.875rem;
}

.success {
    color: #188038;
    margin-top: 0.5rem;
    font-size: 0.875rem;
}

/******************************************************/
.card, .card3 {
    background: white;
    border-radius: 8px;
    padding: 2rem;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    text-align: center;
}

.card3 {
    margin-top: 10px;
}

.form-group {
    margin-bottom: 1rem;
}



.plans {
    display: grid;
    gap: 1rem;
    margin-top: 1rem;
}

.plan-card {
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 1rem;
    cursor: pointer;
    transition: all 0.3s;
}

.plan-card:hover {
    border-color: #1a73e8;
    transform: translateY(-2px);
}

.plan-card.selected {
    border-color: #1a73e8;
    background: #f8f9fe;
}



.hidden {
    display:none;
}

.icon-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: fit-content;
}

.safari-icon {
    height: 200px;
}


// File: app/templates/base.html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>{% block title %}Safari Connect Portal{% endblock %}</title>
        <link rel="stylesheet" href="/static/style.css" />
        <link
        rel="shortcut icon"
        href="/static/resources/safari-icon2.svg"
        type="image/x-icon"
        />
    </head>
    <body>
        <div class="page-container">
            <main>{% block content %}{% endblock %}</main>

            <footer id="footer">
                <p>&copy; 2024 Safari Connect</p>
            </footer>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.2/axios.min.js"></script>
        <script src="/static/index.js"></script>
    </body>
</html>



// File: app/templates/index.html
{% extends "base.html" %}

{% block title %}Safari Connect - Welcome{% endblock %}

{% block content %}
{% include "logo.html" %}
<div class="container">
    <p>Register to enjoy our internet services.</p>

    <form>
        <label for="phone">Phone Number</label>
        <input type="tel" id="phone" name="phone_number" placeholder="+254 XXXXXX" required>
        <button type="submit">Login</button>
    </form>
</div>
{% endblock %}


// File: app/templates/logo.html
<h1 class="titlename">Safari Connect</h1>
<div class="icon-container">
    <img class="safari-icon" src="/static/resources/safari-icon2.svg" alt="safari connect">
</div>
<p style="align-self: center; text-align: center; font-size: medium; font-weight: 300;font-style:italic; font-family: Arial, Helvetica, sans-serif;">
    Explore A Universe Of Possibilities</p>


// File: app/templates/otp_verification.html
{% extends "base.html" %}

{% block title %}Safari Connect - OTP Verification{% endblock %}

{%block content%}
{% include "logo.html" %}
<div class="container">
    <h2>OTP Verification</h2>
    <p>Please enter the OTP sent to your phonr to compete verification.</p>

    <form id="otp-form" onsubmit="return false;">
        <label for="otp">OTP Code:</label>
        <input type="text" id="otp" name="otp_code" placeholder="Enter OTP code" required>
        <button type="submit">Verify OTP</button>
    </form>
</div>
{% endblock %}



// File: app/templates/subscription_expired.html
{% extends "base.html" %}

{% block title %}Safari Connect - Subscription Expired{% endblock %}

{% block content %}
{% include "logo.html" %}
<div class="container">
    <h2>Subscription Expired</h2>
    <p>Your subscription has expired. Please renew to continue enjoying our services.</p>
    <a href="/" class="button-link">Return to Home</a>
</div>
{% endblock %}




// File: app/templates/subscription_success.html
{% extends "base.html" %}

{% block title %}Safari Connect - Subscription Plans{% endblock %}

{% block content %}
{% include "logo.html" %}
<div class="container">
    <h2>Select a Subscription Plan</h2>
    <p>Choose a plan to continue enjoying internet services.</p>

    <div class="plans">
        <div class="plan-card" data-plan="1hr">
            <h3>1 Hour</h3>
            <p>KSh 10</p>
        </div>
        <div class="plan-card" data-plan="2hrs">
            <h3>2 Hours</h3>
            <p>KSh 20</p>
        </div>
        <div class="plan-card" data-plan="3hrs">
            <h3>3 Hours</h3>
            <p>KSh 30</p>
        </div>
        <div class="plan-card" data-plan="8hrs">
            <h3>8 Hours</h3>
            <p>KSh 80</p>
        </div>
        <div class="plan-card" data-plan="12hrs">
            <h3>12 Hours</h3>
            <p>KSh 100</p>
        </div>
        <div class="plan-card" data-plan="24hrs">
            <h3>24 Hours</h3>
            <p>KSh 150</p>
        </div>
        <div class="plan-card" data-plan="3 days">
            <h3>3 Days</h3>
            <p>KSh 300</p>
        </div>
        <div class="plan-card" data-plan="1 week">
            <h3>1 Week</h3>
            <p>KSh 550</p>
        </div>
        <div class="plan-card" data-plan="2 weeks">
            <h3>2 Weeks</h3>
            <p>KSh 1000</p>
        </div>
        <div class="plan-card" data-plan="monthly">
            <h3>Monthly</h3>
            <p>KSh 1750</p>
        </div>
    </div>
    <button id="subscribeBtn" class="hidden">Subscribe</button>
</div>
{% endblock %}



// File: app/utils/timezone.py
# app/utils/timezone.py
from datetime import datetime, timezone
import pytz

def current_utc_time():
    return datetime.now(timezone.utc)

def utc_to_eat(utc_time):
    eat_time_zone = pytz.timezone('Africa/Nairobi')
    return utc_time.astimezone(eat_time_zone)


// File: initserver.py
import socket
import os
import subprocess
import time
import json

def getAddress():
    """Retrieve the IPv4 address of the host."""
    hostname = socket.gethostname()
    try:
        ipv4 = socket.gethostbyname(hostname)
        return ipv4
    except socket.gaierror as e:
        print(f"Error getting IP address: {e}")
        return None


def update_env(ipv4, ngrok_url):
    """Update the .env file with the provided IPv4 and callback URL."""
    env_file_path = ".env"
    db_url = f'DATABASE_URL="postgresql://safariconnect:1Amodung%40%21.@{ipv4}:5432/safaridb"\n'
    cb_url = f'CALLBACK_URL="{ngrok_url}/payment/mpesa/callback"\n\n'
    ngrok = f'NGROK_URL="{ngrok_url}"\n\n'

    if not os.path.exists(env_file_path):
        with open(env_file_path, 'w') as env_file:
            env_file.writelines([db_url, cb_url, ngrok])
        return

    with open(env_file_path, 'r') as env_file:
        lines = env_file.readlines()

    updated = False
    with open(env_file_path, 'w') as env_file:
        for line in lines:
            if line.startswith('DATABASE_URL'):
                env_file.write(db_url)
                updated = True
            elif line.startswith('CALLBACK_URL'):
                env_file.write(cb_url)
                updated = True
            elif line.startswith('NGROK_URL'):
                if line.strip() != ngrok.strip():
                    env_file.write(ngrok)
                    updated = True
            else:
                env_file.write(line)
                
        if not any(line.startswith('NGROK_URL') for line in lines):
            env_file.write(ngrok)

def get_ngrok_url():
    """Start ngrok and retrieve the public URL."""
    try:
        process = subprocess.Popen(['ngrok', 'http', '8000'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        for _ in range(10):  # Wait up to 10 seconds for ngrok to start
            time.sleep(1)
            output, error = subprocess.Popen(
                ['curl', '--silent', 'http://localhost:4040/api/tunnels'],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE
            ).communicate()
            if output:
                try:
                    tunnels = json.loads(output.decode('utf-8'))
                    for tunnel in tunnels.get("tunnels", []):
                        if "http" in tunnel["public_url"]:
                            process.terminate()  # Clean up ngrok process
                            return tunnel["public_url"]
                except (json.JSONDecodeError, KeyError) as e:
                    print(f"Error parsing ngrok response: {e}")
        process.terminate()
        print("Timeout waiting for ngrok.")
        return None
    except Exception as e:
        print(f"Error starting ngrok: {e}")
        return None

def start_server(ipv4):
    """Start the server using Uvicorn."""
    process = subprocess.Popen(
        ["uvicorn", "app.main:app", "--host", ipv4, "--port", "8000", "--reload"]
    )
    try:
        process.wait()
    except KeyboardInterrupt:
        print("\nStopping server...")
        process.terminate()
        process.wait()

if __name__ == "__main__":
    ipv4 = getAddress()
    ngrok_url = get_ngrok_url()

    if ipv4 and ngrok_url:
        print(f"IPv4: {ipv4}")
        print(f"ngrok: {ngrok_url}")
        update_env(ipv4, ngrok_url)
        start_server(ipv4)
    else:
        print("Failed to retrieve IP address or ngrok URL.")




// File: logic flow.scss
// Step 1: User loads the portal page
displayLoadingPage()

// Step 2: Check if the user has an authentication token
if (hasAuthToken()) {
    // Step 3: Validate the token's expiration
    if (isTokenExpired()) {
        // Token is expired, user needs to verify via OTP
        displayOTPVerificationPage()
        
        // Step 4: Wait for OTP verification response
        if (isOTPVerified()) {
            // Reissue a new authentication token
            token = issueNewAuthToken()
            
            // Check if the user has an active subscription
            if (hasActiveSubscription(token)) {
                // User has a valid subscription
                redirectToCountdownPage(getRemainingSessionTime(token))
            } else {
                // No active subscription found
                redirectToSubscriptionPage()
            }
        } else {
            // OTP verification failed or timed out
            displayError("OTP verification failed. Please try again.")
        }
    } else {
        // Token is valid (not expired)
        if (hasActiveSubscription(getAuthToken())) {
            // User has an active subscription
            redirectToCountdownPage(getRemainingSessionTime(getAuthToken()))
        } else {
            // No active subscription found
            redirectToSubscriptionPage()
        }
    }
} else {
    // No authentication token found, new user or session
    displayRegistrationPage()

    // Step 5: User registers and gets verified via OTP
    if (isRegistrationSuccessful() && isOTPVerified()) {
        // Issue a new token after successful registration and OTP
        token = issueNewAuthToken()

        // Check for active subscription
        if (hasActiveSubscription(token)) {
            redirectToCountdownPage(getRemainingSessionTime(token))
        } else {
            redirectToSubscriptionPage()
        }
    } else {
        // Registration or OTP verification failed
        displayError("Registration or OTP verification failed.")
    }
}

// Helper Functions (Pseudocode)
function hasAuthToken() {
    // Check for the existence of a stored token (e.g., in cookies or session)
}

function isTokenExpired() {
    // Validate if the token has passed its expiration date
}

function isOTPVerified() {
    // Process OTP verification and return the result
}

function issueNewAuthToken() {
    // Create and return a new authentication token
}

function hasActiveSubscription(token) {
    // Check with the backend if the token is linked to an active subscription
}

function getRemainingSessionTime(token) {
    // Fetch and return the remaining session time for the user
}

function displayLoadingPage() {
    // Render a loading animation or screen
}

function displayOTPVerificationPage() {
    // Show OTP input and verification page
}

function displayRegistrationPage() {
    // Display the registration page for new users
}

function redirectToCountdownPage(sessionTime) {
    // Redirect user to the countdown page with the session timer
}

function redirectToSubscriptionPage() {
    // Redirect user to a page to select or renew a subscription
}

function displayError(message) {
    // Show an error message to the user
}

function isRegistrationSuccessful() {
    // Return true if user registration is successful
}



// File: OpenWRT/dhcp
# /etc/config/dhcp
config dnsmasq
    option domainneeded '1'
    option boguspriv '1'
    option filterwin2k '0'
    option localise_queries '1'
    option rebind_protection '1'
    option rebind_localhost '1'
    option local '/lan/'
    option domain 'lan'
    option expandhosts '1'
    option nonegcache '0'
    option authoritative '1'
    option readethers '1'
    option leasefile '/tmp/dhcp.leases'
    option resolvfile '/tmp/resolv.conf.auto'

config dhcp 'lan'
    option interface 'lan'
    option start '100'
    option limit '150'
    option leasetime '12h'


// File: OpenWRT/firewll
# Firewall rules (/etc/config/firewall)
# Allow access to captive portal
config rule
    option name 'Allow-Captive-Portal'
    option src 'lan', 'wlan', 'wan'
    option dest_port '8000'
    option proto 'tcp'
    option target 'ACCEPT'

# Block all other traffic for unauthenticated users
config rule
    option name 'Block-Unauthenticated'
    option src 'lan'
    option proto 'all'
    option target 'DROP'

# Config for Mpesa Callback IPS Whitelist
config rule
    option name 'Allow-Mpesa-Callback-1'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.214.200'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-2'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.214.206'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-3'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.213.114'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-4'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'        
    option src_ip '196.201.214.207'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-5'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.214.208'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-6'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.213.44'
    option target 'ACCEPT'
    
config rule
    option name 'Allow-Mpesa-Callback-7'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'             
    option src_ip '196.201.212.127'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-8'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.212.138'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-9'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.212.129'
    option target 'ACCEPT'
    
config rule
    option name 'Allow-Mpesa-Callback-10'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102' 
    option dest_port '8000'              
    option src_ip '196.201.212.136'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-11'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.212.74'
    option target 'ACCEPT'

config rule
    option name 'Allow-Mpesa-Callback-12'
    option src 'wan'
    option dest 'lan'
    option proto 'tcp'
    option dest_ip '192.168.0.102'
    option dest_port '8000'
    option src_ip '196.201.212.69'
    option target 'ACCEPT'




// File: OpenWRT/network
# /etc/config/network
config interface 'loopback' # type: ignore
    option device 'lo' # type: ignore
    option proto 'static' # type: ignore
    option ipaddr '127.0.0.1' # type: ignore
    option netmask '255.0.0.0' # type: ignore

config interface 'lan' # type: ignore
    option device 'eth0' # type: ignore
    option proto 'static' # type: ignore
    option ipaddr '192.168.1.1' # type: ignore
    option netmask '255.255.255.0' # type: ignore


// File: OpenWRT/nodogsplash
# /etc/config/nodogsplash
config nodogsplash
    option enabled '1'
    option gatewayname 'WiFi Hotspot'
    option gatewayinterface 'br-lan'
    option maxclients '250'
    option clientidletimeout '1440'
    option webroot '/etc/nodogsplash/htdocs'
    option redirecturl 'http://your-portal-url'
    
# Authentication script
option authenticateimmediately '0'
option passwordattempts '5'
option gatewayiprange '192.168.1.0/24'


// File: requirements.txt
fastapi
uvicorn
sqlalchemy
psycopg2-binary
africastalking
jwt
python-jose
pydantic
pydantic-settings
pytz
jinja2
httpx


// File: secret.py
import secrets

def secretKey():
    secret= secrets.token_hex(64)
    print(f"{secret}\n")

secretKey()


// File: tests/dbconfig.py
from sqlalchemy import create_engine, MetaData

DATABASE_URL = "postgresql://safariconnect:1Amodung%40%21.@192.168.0.100:5432/safaridb"
engine = create_engine(DATABASE_URL)
metadata = MetaData()

# Test connection
try:
    with engine.connect() as connection:
        print("Database connected successfully.")
except Exception as e:
    print(f"Error connecting to database: {e}")



// File: tests/testotp.py
def generate_otp():
    # Generate 6-digit OTP
    import random
    return str(random.randint(100000, 999999))

try:
    otp = generate_otp()
    print(f"OTP GENERATED: {otp}")
except Exception as e:
    print(f"Error generating OTP: {e}")


